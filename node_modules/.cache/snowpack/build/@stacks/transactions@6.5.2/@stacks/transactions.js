import { hexToBytes, utf8ToBytes, bytesToAscii, bytesToHex, asciiToBytes, intToBigInt, parseRecoverableSignatureVrs, hexToBigInt, signatureRsvToVrs, concatArray, privateKeyToBytes, PRIVATE_KEY_COMPRESSED_LENGTH, intToHex, signatureVrsToRsv, writeUInt32BE, intToBytes, hexToInt, bytesToUtf8, concatBytes, bigIntToBytes, toTwos, readUInt32BE, readUInt8, readUInt16BE, with0x, writeUInt16BE } from '@stacks/common';
import { ripemd160 } from '@noble/hashes/ripemd160';
import { sha256 } from '@noble/hashes/sha256';
import { sha512_256 } from '@noble/hashes/sha512';
import { utils, Signature, Point, getPublicKey as getPublicKey$1, signSync } from '@noble/secp256k1';
export { verify as verifySignature } from '@noble/secp256k1';
import { c32address, c32addressDecode } from 'c32check';
import lodashCloneDeep from 'lodash.clonedeep';
import { hmac } from '@noble/hashes/hmac';
import { StacksNetwork, StacksMainnet, createFetchFn, StacksTestnet } from '@stacks/network';

var ChainID;
(function (ChainID) {
    ChainID[ChainID["Testnet"] = 2147483648] = "Testnet";
    ChainID[ChainID["Mainnet"] = 1] = "Mainnet";
})(ChainID || (ChainID = {}));
const DEFAULT_CHAIN_ID = ChainID.Mainnet;
const MAX_STRING_LENGTH_BYTES = 128;
const CLARITY_INT_SIZE = 128;
const CLARITY_INT_BYTE_SIZE = 16;
const COINBASE_LENGTH_BYTES = 32;
const RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;
const COMPRESSED_PUBKEY_LENGTH_BYTES = 32;
const UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;
const MEMO_MAX_LENGTH_BYTES = 34;
const DEFAULT_CORE_NODE_API_URL = 'https://stacks-node-api.mainnet.stacks.co';
var StacksMessageType;
(function (StacksMessageType) {
    StacksMessageType[StacksMessageType["Address"] = 0] = "Address";
    StacksMessageType[StacksMessageType["Principal"] = 1] = "Principal";
    StacksMessageType[StacksMessageType["LengthPrefixedString"] = 2] = "LengthPrefixedString";
    StacksMessageType[StacksMessageType["MemoString"] = 3] = "MemoString";
    StacksMessageType[StacksMessageType["AssetInfo"] = 4] = "AssetInfo";
    StacksMessageType[StacksMessageType["PostCondition"] = 5] = "PostCondition";
    StacksMessageType[StacksMessageType["PublicKey"] = 6] = "PublicKey";
    StacksMessageType[StacksMessageType["LengthPrefixedList"] = 7] = "LengthPrefixedList";
    StacksMessageType[StacksMessageType["Payload"] = 8] = "Payload";
    StacksMessageType[StacksMessageType["MessageSignature"] = 9] = "MessageSignature";
    StacksMessageType[StacksMessageType["StructuredDataSignature"] = 10] = "StructuredDataSignature";
    StacksMessageType[StacksMessageType["TransactionAuthField"] = 11] = "TransactionAuthField";
})(StacksMessageType || (StacksMessageType = {}));
function whenMessageType(messageType) {
    return (messageTypeMap) => messageTypeMap[messageType];
}
var PayloadType;
(function (PayloadType) {
    PayloadType[PayloadType["TokenTransfer"] = 0] = "TokenTransfer";
    PayloadType[PayloadType["SmartContract"] = 1] = "SmartContract";
    PayloadType[PayloadType["VersionedSmartContract"] = 6] = "VersionedSmartContract";
    PayloadType[PayloadType["ContractCall"] = 2] = "ContractCall";
    PayloadType[PayloadType["PoisonMicroblock"] = 3] = "PoisonMicroblock";
    PayloadType[PayloadType["Coinbase"] = 4] = "Coinbase";
    PayloadType[PayloadType["CoinbaseToAltRecipient"] = 5] = "CoinbaseToAltRecipient";
})(PayloadType || (PayloadType = {}));
var ClarityVersion;
(function (ClarityVersion) {
    ClarityVersion[ClarityVersion["Clarity1"] = 1] = "Clarity1";
    ClarityVersion[ClarityVersion["Clarity2"] = 2] = "Clarity2";
})(ClarityVersion || (ClarityVersion = {}));
var AnchorMode;
(function (AnchorMode) {
    AnchorMode[AnchorMode["OnChainOnly"] = 1] = "OnChainOnly";
    AnchorMode[AnchorMode["OffChainOnly"] = 2] = "OffChainOnly";
    AnchorMode[AnchorMode["Any"] = 3] = "Any";
})(AnchorMode || (AnchorMode = {}));
const AnchorModeNames = ['onChainOnly', 'offChainOnly', 'any'];
const AnchorModeMap = {
    [AnchorModeNames[0]]: AnchorMode.OnChainOnly,
    [AnchorModeNames[1]]: AnchorMode.OffChainOnly,
    [AnchorModeNames[2]]: AnchorMode.Any,
    [AnchorMode.OnChainOnly]: AnchorMode.OnChainOnly,
    [AnchorMode.OffChainOnly]: AnchorMode.OffChainOnly,
    [AnchorMode.Any]: AnchorMode.Any,
};
function anchorModeFromNameOrValue(mode) {
    if (mode in AnchorModeMap) {
        return AnchorModeMap[mode];
    }
    throw new Error(`Invalid anchor mode "${mode}", must be one of: ${AnchorModeNames.join(', ')}`);
}
var TransactionVersion;
(function (TransactionVersion) {
    TransactionVersion[TransactionVersion["Mainnet"] = 0] = "Mainnet";
    TransactionVersion[TransactionVersion["Testnet"] = 128] = "Testnet";
})(TransactionVersion || (TransactionVersion = {}));
const DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;
var PostConditionMode;
(function (PostConditionMode) {
    PostConditionMode[PostConditionMode["Allow"] = 1] = "Allow";
    PostConditionMode[PostConditionMode["Deny"] = 2] = "Deny";
})(PostConditionMode || (PostConditionMode = {}));
var PostConditionType;
(function (PostConditionType) {
    PostConditionType[PostConditionType["STX"] = 0] = "STX";
    PostConditionType[PostConditionType["Fungible"] = 1] = "Fungible";
    PostConditionType[PostConditionType["NonFungible"] = 2] = "NonFungible";
})(PostConditionType || (PostConditionType = {}));
var AuthType;
(function (AuthType) {
    AuthType[AuthType["Standard"] = 4] = "Standard";
    AuthType[AuthType["Sponsored"] = 5] = "Sponsored";
})(AuthType || (AuthType = {}));
var AddressHashMode;
(function (AddressHashMode) {
    AddressHashMode[AddressHashMode["SerializeP2PKH"] = 0] = "SerializeP2PKH";
    AddressHashMode[AddressHashMode["SerializeP2SH"] = 1] = "SerializeP2SH";
    AddressHashMode[AddressHashMode["SerializeP2WPKH"] = 2] = "SerializeP2WPKH";
    AddressHashMode[AddressHashMode["SerializeP2WSH"] = 3] = "SerializeP2WSH";
})(AddressHashMode || (AddressHashMode = {}));
var AddressVersion;
(function (AddressVersion) {
    AddressVersion[AddressVersion["MainnetSingleSig"] = 22] = "MainnetSingleSig";
    AddressVersion[AddressVersion["MainnetMultiSig"] = 20] = "MainnetMultiSig";
    AddressVersion[AddressVersion["TestnetSingleSig"] = 26] = "TestnetSingleSig";
    AddressVersion[AddressVersion["TestnetMultiSig"] = 21] = "TestnetMultiSig";
})(AddressVersion || (AddressVersion = {}));
var PubKeyEncoding;
(function (PubKeyEncoding) {
    PubKeyEncoding[PubKeyEncoding["Compressed"] = 0] = "Compressed";
    PubKeyEncoding[PubKeyEncoding["Uncompressed"] = 1] = "Uncompressed";
})(PubKeyEncoding || (PubKeyEncoding = {}));
var FungibleConditionCode;
(function (FungibleConditionCode) {
    FungibleConditionCode[FungibleConditionCode["Equal"] = 1] = "Equal";
    FungibleConditionCode[FungibleConditionCode["Greater"] = 2] = "Greater";
    FungibleConditionCode[FungibleConditionCode["GreaterEqual"] = 3] = "GreaterEqual";
    FungibleConditionCode[FungibleConditionCode["Less"] = 4] = "Less";
    FungibleConditionCode[FungibleConditionCode["LessEqual"] = 5] = "LessEqual";
})(FungibleConditionCode || (FungibleConditionCode = {}));
var NonFungibleConditionCode;
(function (NonFungibleConditionCode) {
    NonFungibleConditionCode[NonFungibleConditionCode["Sends"] = 16] = "Sends";
    NonFungibleConditionCode[NonFungibleConditionCode["DoesNotSend"] = 17] = "DoesNotSend";
})(NonFungibleConditionCode || (NonFungibleConditionCode = {}));
var PostConditionPrincipalID;
(function (PostConditionPrincipalID) {
    PostConditionPrincipalID[PostConditionPrincipalID["Origin"] = 1] = "Origin";
    PostConditionPrincipalID[PostConditionPrincipalID["Standard"] = 2] = "Standard";
    PostConditionPrincipalID[PostConditionPrincipalID["Contract"] = 3] = "Contract";
})(PostConditionPrincipalID || (PostConditionPrincipalID = {}));
var AssetType;
(function (AssetType) {
    AssetType[AssetType["STX"] = 0] = "STX";
    AssetType[AssetType["Fungible"] = 1] = "Fungible";
    AssetType[AssetType["NonFungible"] = 2] = "NonFungible";
})(AssetType || (AssetType = {}));
var TxRejectedReason;
(function (TxRejectedReason) {
    TxRejectedReason["Serialization"] = "Serialization";
    TxRejectedReason["Deserialization"] = "Deserialization";
    TxRejectedReason["SignatureValidation"] = "SignatureValidation";
    TxRejectedReason["FeeTooLow"] = "FeeTooLow";
    TxRejectedReason["BadNonce"] = "BadNonce";
    TxRejectedReason["NotEnoughFunds"] = "NotEnoughFunds";
    TxRejectedReason["NoSuchContract"] = "NoSuchContract";
    TxRejectedReason["NoSuchPublicFunction"] = "NoSuchPublicFunction";
    TxRejectedReason["BadFunctionArgument"] = "BadFunctionArgument";
    TxRejectedReason["ContractAlreadyExists"] = "ContractAlreadyExists";
    TxRejectedReason["PoisonMicroblocksDoNotConflict"] = "PoisonMicroblocksDoNotConflict";
    TxRejectedReason["PoisonMicroblockHasUnknownPubKeyHash"] = "PoisonMicroblockHasUnknownPubKeyHash";
    TxRejectedReason["PoisonMicroblockIsInvalid"] = "PoisonMicroblockIsInvalid";
    TxRejectedReason["BadAddressVersionByte"] = "BadAddressVersionByte";
    TxRejectedReason["NoCoinbaseViaMempool"] = "NoCoinbaseViaMempool";
    TxRejectedReason["ServerFailureNoSuchChainTip"] = "ServerFailureNoSuchChainTip";
    TxRejectedReason["ServerFailureDatabase"] = "ServerFailureDatabase";
    TxRejectedReason["ServerFailureOther"] = "ServerFailureOther";
})(TxRejectedReason || (TxRejectedReason = {}));

function createMessageSignature(signature) {
    const length = hexToBytes(signature).byteLength;
    if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {
        throw Error('Invalid signature');
    }
    return {
        type: StacksMessageType.MessageSignature,
        data: signature,
    };
}
function addressHashModeToVersion(hashMode, txVersion) {
    switch (hashMode) {
        case AddressHashMode.SerializeP2PKH:
            switch (txVersion) {
                case TransactionVersion.Mainnet:
                    return AddressVersion.MainnetSingleSig;
                case TransactionVersion.Testnet:
                    return AddressVersion.TestnetSingleSig;
                default:
                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
            }
        case AddressHashMode.SerializeP2SH:
        case AddressHashMode.SerializeP2WPKH:
        case AddressHashMode.SerializeP2WSH:
            switch (txVersion) {
                case TransactionVersion.Mainnet:
                    return AddressVersion.MainnetMultiSig;
                case TransactionVersion.Testnet:
                    return AddressVersion.TestnetMultiSig;
                default:
                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
            }
        default:
            throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);
    }
}
function addressFromVersionHash(version, hash) {
    return { type: StacksMessageType.Address, version, hash160: hash };
}
function addressToString(address) {
    return c32address(address.version, address.hash160);
}

function parseAssetInfoString(id) {
    const [assetAddress, assetContractName, assetTokenName] = id.split(/\.|::/);
    const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);
    return assetInfo;
}
function createLPString(content, lengthPrefixBytes, maxLengthBytes) {
    const prefixLength = lengthPrefixBytes || 1;
    const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;
    if (exceedsMaxLengthBytes(content, maxLength)) {
        throw new Error(`String length exceeds maximum bytes ${maxLength}`);
    }
    return {
        type: StacksMessageType.LengthPrefixedString,
        content,
        lengthPrefixBytes: prefixLength,
        maxLengthBytes: maxLength,
    };
}
function createAssetInfo(addressString, contractName, assetName) {
    return {
        type: StacksMessageType.AssetInfo,
        address: createAddress(addressString),
        contractName: createLPString(contractName),
        assetName: createLPString(assetName),
    };
}
function createAddress(c32AddressString) {
    const addressData = c32addressDecode(c32AddressString);
    return {
        type: StacksMessageType.Address,
        version: addressData[0],
        hash160: addressData[1],
    };
}
function parsePrincipalString(principalString) {
    if (principalString.includes('.')) {
        const [address, contractName] = principalString.split('.');
        return createContractPrincipal(address, contractName);
    }
    else {
        return createStandardPrincipal(principalString);
    }
}
function createContractPrincipal(addressString, contractName) {
    const addr = createAddress(addressString);
    const name = createLPString(contractName);
    return {
        type: StacksMessageType.Principal,
        prefix: PostConditionPrincipalID.Contract,
        address: addr,
        contractName: name,
    };
}
function createStandardPrincipal(addressString) {
    const addr = createAddress(addressString);
    return {
        type: StacksMessageType.Principal,
        prefix: PostConditionPrincipalID.Standard,
        address: addr,
    };
}

var ClarityType;
(function (ClarityType) {
    ClarityType[ClarityType["Int"] = 0] = "Int";
    ClarityType[ClarityType["UInt"] = 1] = "UInt";
    ClarityType[ClarityType["Buffer"] = 2] = "Buffer";
    ClarityType[ClarityType["BoolTrue"] = 3] = "BoolTrue";
    ClarityType[ClarityType["BoolFalse"] = 4] = "BoolFalse";
    ClarityType[ClarityType["PrincipalStandard"] = 5] = "PrincipalStandard";
    ClarityType[ClarityType["PrincipalContract"] = 6] = "PrincipalContract";
    ClarityType[ClarityType["ResponseOk"] = 7] = "ResponseOk";
    ClarityType[ClarityType["ResponseErr"] = 8] = "ResponseErr";
    ClarityType[ClarityType["OptionalNone"] = 9] = "OptionalNone";
    ClarityType[ClarityType["OptionalSome"] = 10] = "OptionalSome";
    ClarityType[ClarityType["List"] = 11] = "List";
    ClarityType[ClarityType["Tuple"] = 12] = "Tuple";
    ClarityType[ClarityType["StringASCII"] = 13] = "StringASCII";
    ClarityType[ClarityType["StringUTF8"] = 14] = "StringUTF8";
})(ClarityType || (ClarityType = {}));

function principalToString(principal) {
    if (principal.type === ClarityType.PrincipalStandard) {
        return addressToString(principal.address);
    }
    else if (principal.type === ClarityType.PrincipalContract) {
        const address = addressToString(principal.address);
        return `${address}.${principal.contractName.content}`;
    }
    else {
        throw new Error(`Unexpected principal data: ${JSON.stringify(principal)}`);
    }
}
function principalCV(principal) {
    if (principal.includes('.')) {
        const [address, contractName] = principal.split('.');
        return contractPrincipalCV(address, contractName);
    }
    else {
        return standardPrincipalCV(principal);
    }
}
function standardPrincipalCV(addressString) {
    const addr = createAddress(addressString);
    return { type: ClarityType.PrincipalStandard, address: addr };
}
function standardPrincipalCVFromAddress(address) {
    return { type: ClarityType.PrincipalStandard, address };
}
function contractPrincipalCV(addressString, contractName) {
    const addr = createAddress(addressString);
    const lengthPrefixedContractName = createLPString(contractName);
    return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);
}
function contractPrincipalCVFromAddress(address, contractName) {
    if (utf8ToBytes(contractName.content).byteLength >= 128) {
        throw new Error('Contract name must be less than 128 bytes');
    }
    return { type: ClarityType.PrincipalContract, address, contractName };
}
function contractPrincipalCVFromStandard(sp, contractName) {
    const lengthPrefixedContractName = createLPString(contractName);
    return {
        type: ClarityType.PrincipalContract,
        address: sp.address,
        contractName: lengthPrefixedContractName,
    };
}

function cvToString(val, encoding = 'hex') {
    switch (val.type) {
        case ClarityType.BoolTrue:
            return 'true';
        case ClarityType.BoolFalse:
            return 'false';
        case ClarityType.Int:
            return val.value.toString();
        case ClarityType.UInt:
            return `u${val.value.toString()}`;
        case ClarityType.Buffer:
            if (encoding === 'tryAscii') {
                const str = bytesToAscii(val.buffer);
                if (/[ -~]/.test(str)) {
                    return JSON.stringify(str);
                }
            }
            return `0x${bytesToHex(val.buffer)}`;
        case ClarityType.OptionalNone:
            return 'none';
        case ClarityType.OptionalSome:
            return `(some ${cvToString(val.value, encoding)})`;
        case ClarityType.ResponseErr:
            return `(err ${cvToString(val.value, encoding)})`;
        case ClarityType.ResponseOk:
            return `(ok ${cvToString(val.value, encoding)})`;
        case ClarityType.PrincipalStandard:
        case ClarityType.PrincipalContract:
            return principalToString(val);
        case ClarityType.List:
            return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;
        case ClarityType.Tuple:
            return `(tuple ${Object.keys(val.data)
                .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)
                .join(' ')})`;
        case ClarityType.StringASCII:
            return `"${val.data}"`;
        case ClarityType.StringUTF8:
            return `u"${val.data}"`;
    }
}
function cvToValue(val, strictJsonCompat = false) {
    switch (val.type) {
        case ClarityType.BoolTrue:
            return true;
        case ClarityType.BoolFalse:
            return false;
        case ClarityType.Int:
        case ClarityType.UInt:
            if (strictJsonCompat) {
                return val.value.toString();
            }
            return val.value;
        case ClarityType.Buffer:
            return `0x${bytesToHex(val.buffer)}`;
        case ClarityType.OptionalNone:
            return null;
        case ClarityType.OptionalSome:
            return cvToJSON(val.value);
        case ClarityType.ResponseErr:
            return cvToJSON(val.value);
        case ClarityType.ResponseOk:
            return cvToJSON(val.value);
        case ClarityType.PrincipalStandard:
        case ClarityType.PrincipalContract:
            return principalToString(val);
        case ClarityType.List:
            return val.list.map(v => cvToJSON(v));
        case ClarityType.Tuple:
            const result = {};
            Object.keys(val.data).forEach(key => {
                result[key] = cvToJSON(val.data[key]);
            });
            return result;
        case ClarityType.StringASCII:
            return val.data;
        case ClarityType.StringUTF8:
            return val.data;
    }
}
function cvToJSON(val) {
    switch (val.type) {
        case ClarityType.ResponseErr:
            return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };
        case ClarityType.ResponseOk:
            return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };
        default:
            return { type: getCVTypeString(val), value: cvToValue(val, true) };
    }
}
function getCVTypeString(val) {
    switch (val.type) {
        case ClarityType.BoolTrue:
        case ClarityType.BoolFalse:
            return 'bool';
        case ClarityType.Int:
            return 'int';
        case ClarityType.UInt:
            return 'uint';
        case ClarityType.Buffer:
            return `(buff ${val.buffer.length})`;
        case ClarityType.OptionalNone:
            return '(optional none)';
        case ClarityType.OptionalSome:
            return `(optional ${getCVTypeString(val.value)})`;
        case ClarityType.ResponseErr:
            return `(response UnknownType ${getCVTypeString(val.value)})`;
        case ClarityType.ResponseOk:
            return `(response ${getCVTypeString(val.value)} UnknownType)`;
        case ClarityType.PrincipalStandard:
        case ClarityType.PrincipalContract:
            return 'principal';
        case ClarityType.List:
            return `(list ${val.list.length} ${val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'})`;
        case ClarityType.Tuple:
            return `(tuple ${Object.keys(val.data)
                .map(key => `(${key} ${getCVTypeString(val.data[key])})`)
                .join(' ')})`;
        case ClarityType.StringASCII:
            return `(string-ascii ${asciiToBytes(val.data).length})`;
        case ClarityType.StringUTF8:
            return `(string-utf8 ${utf8ToBytes(val.data).length})`;
    }
}

const trueCV = () => ({ type: ClarityType.BoolTrue });
const falseCV = () => ({ type: ClarityType.BoolFalse });
const boolCV = (bool) => (bool ? trueCV() : falseCV());

const MAX_U128 = BigInt('0xffffffffffffffffffffffffffffffff');
const MIN_U128 = BigInt(0);
const MAX_I128 = BigInt('0x7fffffffffffffffffffffffffffffff');
const MIN_I128 = BigInt('-170141183460469231731687303715884105728');
const intCV = (value) => {
    const bigInt = intToBigInt(value, true);
    if (bigInt > MAX_I128) {
        throw new RangeError(`Cannot construct clarity integer from value greater than ${MAX_I128}`);
    }
    else if (bigInt < MIN_I128) {
        throw new RangeError(`Cannot construct clarity integer form value less than ${MIN_I128}`);
    }
    return { type: ClarityType.Int, value: bigInt };
};
const uintCV = (value) => {
    const bigInt = intToBigInt(value, false);
    if (bigInt < MIN_U128) {
        throw new RangeError('Cannot construct unsigned clarity integer from negative value');
    }
    else if (bigInt > MAX_U128) {
        throw new RangeError(`Cannot construct unsigned clarity integer greater than ${MAX_U128}`);
    }
    return { type: ClarityType.UInt, value: bigInt };
};

const bufferCV = (buffer) => {
    if (buffer.length > 1000000) {
        throw new Error('Cannot construct clarity buffer that is greater than 1MB');
    }
    return { type: ClarityType.Buffer, buffer };
};
const bufferCVFromString = (str) => bufferCV(utf8ToBytes(str));

function noneCV() {
    return { type: ClarityType.OptionalNone };
}
function someCV(value) {
    return { type: ClarityType.OptionalSome, value };
}
function optionalCVOf(value) {
    if (value) {
        return someCV(value);
    }
    else {
        return noneCV();
    }
}

function responseErrorCV(value) {
    return { type: ClarityType.ResponseErr, value };
}
function responseOkCV(value) {
    return { type: ClarityType.ResponseOk, value };
}

function listCV(values) {
    return { type: ClarityType.List, list: values };
}

function tupleCV(data) {
    for (const key in data) {
        if (!isClarityName(key)) {
            throw new Error(`"${key}" is not a valid Clarity name`);
        }
    }
    return { type: ClarityType.Tuple, data };
}

const stringAsciiCV = (data) => {
    return { type: ClarityType.StringASCII, data };
};
const stringUtf8CV = (data) => {
    return { type: ClarityType.StringUTF8, data };
};
const stringCV = (data, encoding) => {
    switch (encoding) {
        case 'ascii':
            return stringAsciiCV(data);
        case 'utf8':
            return stringUtf8CV(data);
    }
};

utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac.create(sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
function getAddressFromPrivateKey(privateKey, transactionVersion = TransactionVersion.Mainnet) {
    const pubKey = pubKeyfromPrivKey(privateKey);
    return getAddressFromPublicKey(pubKey.data, transactionVersion);
}
function getAddressFromPublicKey(publicKey, transactionVersion = TransactionVersion.Mainnet) {
    publicKey = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);
    const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);
    const addr = addressFromVersionHash(addrVer, hashP2PKH(hexToBytes(publicKey)));
    const addrString = addressToString(addr);
    return addrString;
}
function createStacksPublicKey(key) {
    return {
        type: StacksMessageType.PublicKey,
        data: hexToBytes(key),
    };
}
function publicKeyFromSignatureVrs(messageHash, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {
    const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);
    const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));
    const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);
    const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;
    return point.toHex(compressed);
}
function publicKeyFromSignatureRsv(messageHash, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {
    return publicKeyFromSignatureVrs(messageHash, { ...messageSignature, data: signatureRsvToVrs(messageSignature.data) }, pubKeyEncoding);
}
function publicKeyFromBytes(data) {
    return { type: StacksMessageType.PublicKey, data };
}
function isCompressed(key) {
    return !bytesToHex(key.data).startsWith('04');
}
function publicKeyToString(key) {
    return bytesToHex(key.data);
}
function serializePublicKey(key) {
    return key.data.slice();
}
function pubKeyfromPrivKey(privateKey) {
    const privKey = createStacksPrivateKey(privateKey);
    const publicKey = getPublicKey$1(privKey.data.slice(0, 32), privKey.compressed);
    return createStacksPublicKey(bytesToHex(publicKey));
}
function compressPublicKey(publicKey) {
    const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);
    const compressed = Point.fromHex(hex).toHex(true);
    return createStacksPublicKey(compressed);
}
function deserializePublicKey(bytesReader) {
    const fieldId = bytesReader.readUInt8();
    const keyLength = fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;
    return publicKeyFromBytes(concatArray([fieldId, bytesReader.readBytes(keyLength)]));
}
function createStacksPrivateKey(key) {
    const data = privateKeyToBytes(key);
    const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;
    return { data, compressed };
}
function makeRandomPrivKey() {
    return createStacksPrivateKey(utils.randomPrivateKey());
}
function signWithKey(privateKey, messageHash) {
    const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {
        canonical: true,
        recovered: true,
    });
    if (recoveryId == null) {
        throw new Error('No signature recoveryId received');
    }
    const recoveryIdHex = intToHex(recoveryId, 1);
    const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex();
    return createMessageSignature(recoverableSignatureString);
}
function signMessageHashRsv({ messageHash, privateKey, }) {
    const messageSignature = signWithKey(privateKey, messageHash);
    return { ...messageSignature, data: signatureVrsToRsv(messageSignature.data) };
}
function getPublicKey(privateKey) {
    return pubKeyfromPrivKey(privateKey.data);
}
function privateKeyToString(privateKey) {
    return bytesToHex(privateKey.data);
}
function publicKeyToAddress(version, publicKey) {
    return c32address(version, bytesToHex(hash160(publicKey.data)));
}

function isTokenTransferPayload(p) {
    return p.payloadType === PayloadType.TokenTransfer;
}
function isContractCallPayload(p) {
    return p.payloadType === PayloadType.ContractCall;
}
function isSmartContractPayload(p) {
    return p.payloadType === PayloadType.SmartContract;
}
function isPoisonPayload(p) {
    return p.payloadType === PayloadType.PoisonMicroblock;
}
function isCoinbasePayload(p) {
    return p.payloadType === PayloadType.Coinbase;
}
function createTokenTransferPayload(recipient, amount, memo) {
    if (typeof recipient === 'string') {
        recipient = principalCV(recipient);
    }
    if (typeof memo === 'string') {
        memo = createMemoString(memo);
    }
    return {
        type: StacksMessageType.Payload,
        payloadType: PayloadType.TokenTransfer,
        recipient,
        amount: intToBigInt(amount, false),
        memo: memo ?? createMemoString(''),
    };
}
function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {
    if (typeof contractAddress === 'string') {
        contractAddress = createAddress(contractAddress);
    }
    if (typeof contractName === 'string') {
        contractName = createLPString(contractName);
    }
    if (typeof functionName === 'string') {
        functionName = createLPString(functionName);
    }
    return {
        type: StacksMessageType.Payload,
        payloadType: PayloadType.ContractCall,
        contractAddress,
        contractName,
        functionName,
        functionArgs,
    };
}
function createSmartContractPayload(contractName, codeBody, clarityVersion) {
    if (typeof contractName === 'string') {
        contractName = createLPString(contractName);
    }
    if (typeof codeBody === 'string') {
        codeBody = codeBodyString(codeBody);
    }
    if (typeof clarityVersion === 'number') {
        return {
            type: StacksMessageType.Payload,
            payloadType: PayloadType.VersionedSmartContract,
            clarityVersion,
            contractName,
            codeBody,
        };
    }
    return {
        type: StacksMessageType.Payload,
        payloadType: PayloadType.SmartContract,
        contractName,
        codeBody,
    };
}
function createPoisonPayload() {
    return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };
}
function createCoinbasePayload(coinbaseBytes, altRecipient) {
    if (coinbaseBytes.byteLength != COINBASE_LENGTH_BYTES) {
        throw Error(`Coinbase buffer size must be ${COINBASE_LENGTH_BYTES} bytes`);
    }
    if (altRecipient != undefined) {
        return {
            type: StacksMessageType.Payload,
            payloadType: PayloadType.CoinbaseToAltRecipient,
            coinbaseBytes,
            recipient: altRecipient,
        };
    }
    return {
        type: StacksMessageType.Payload,
        payloadType: PayloadType.Coinbase,
        coinbaseBytes,
    };
}
function serializePayload(payload) {
    const bytesArray = [];
    bytesArray.push(payload.payloadType);
    switch (payload.payloadType) {
        case PayloadType.TokenTransfer:
            bytesArray.push(serializeCV(payload.recipient));
            bytesArray.push(intToBytes(payload.amount, false, 8));
            bytesArray.push(serializeStacksMessage(payload.memo));
            break;
        case PayloadType.ContractCall:
            bytesArray.push(serializeStacksMessage(payload.contractAddress));
            bytesArray.push(serializeStacksMessage(payload.contractName));
            bytesArray.push(serializeStacksMessage(payload.functionName));
            const numArgs = new Uint8Array(4);
            writeUInt32BE(numArgs, payload.functionArgs.length, 0);
            bytesArray.push(numArgs);
            payload.functionArgs.forEach(arg => {
                bytesArray.push(serializeCV(arg));
            });
            break;
        case PayloadType.SmartContract:
            bytesArray.push(serializeStacksMessage(payload.contractName));
            bytesArray.push(serializeStacksMessage(payload.codeBody));
            break;
        case PayloadType.VersionedSmartContract:
            bytesArray.push(payload.clarityVersion);
            bytesArray.push(serializeStacksMessage(payload.contractName));
            bytesArray.push(serializeStacksMessage(payload.codeBody));
            break;
        case PayloadType.PoisonMicroblock:
            break;
        case PayloadType.Coinbase:
            bytesArray.push(payload.coinbaseBytes);
            break;
        case PayloadType.CoinbaseToAltRecipient:
            bytesArray.push(payload.coinbaseBytes);
            bytesArray.push(serializeCV(payload.recipient));
            break;
    }
    return concatArray(bytesArray);
}
function deserializePayload(bytesReader) {
    const payloadType = bytesReader.readUInt8Enum(PayloadType, n => {
        throw new Error(`Cannot recognize PayloadType: ${n}`);
    });
    switch (payloadType) {
        case PayloadType.TokenTransfer:
            const recipient = deserializeCV(bytesReader);
            const amount = intToBigInt(bytesReader.readBytes(8), false);
            const memo = deserializeMemoString(bytesReader);
            return createTokenTransferPayload(recipient, amount, memo);
        case PayloadType.ContractCall:
            const contractAddress = deserializeAddress(bytesReader);
            const contractCallName = deserializeLPString(bytesReader);
            const functionName = deserializeLPString(bytesReader);
            const functionArgs = [];
            const numberOfArgs = bytesReader.readUInt32BE();
            for (let i = 0; i < numberOfArgs; i++) {
                const clarityValue = deserializeCV(bytesReader);
                functionArgs.push(clarityValue);
            }
            return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);
        case PayloadType.SmartContract:
            const smartContractName = deserializeLPString(bytesReader);
            const codeBody = deserializeLPString(bytesReader, 4, 100000);
            return createSmartContractPayload(smartContractName, codeBody);
        case PayloadType.VersionedSmartContract: {
            const clarityVersion = bytesReader.readUInt8Enum(ClarityVersion, n => {
                throw new Error(`Cannot recognize ClarityVersion: ${n}`);
            });
            const smartContractName = deserializeLPString(bytesReader);
            const codeBody = deserializeLPString(bytesReader, 4, 100000);
            return createSmartContractPayload(smartContractName, codeBody, clarityVersion);
        }
        case PayloadType.PoisonMicroblock:
            return createPoisonPayload();
        case PayloadType.Coinbase:
            const coinbaseBytes = bytesReader.readBytes(COINBASE_LENGTH_BYTES);
            return createCoinbasePayload(coinbaseBytes);
        case PayloadType.CoinbaseToAltRecipient:
            const coinbaseToAltRecipientBuffer = bytesReader.readBytes(COINBASE_LENGTH_BYTES);
            const altRecipient = deserializeCV(bytesReader);
            return createCoinbasePayload(coinbaseToAltRecipientBuffer, altRecipient);
    }
}

class TransactionError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = this.constructor.name;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
class SerializationError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
class DeserializationError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
class NoEstimateAvailableError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
class NotImplementedError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
class SigningError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
class VerificationError extends TransactionError {
    constructor(message) {
        super(message);
    }
}

var AuthFieldType;
(function (AuthFieldType) {
    AuthFieldType[AuthFieldType["PublicKeyCompressed"] = 0] = "PublicKeyCompressed";
    AuthFieldType[AuthFieldType["PublicKeyUncompressed"] = 1] = "PublicKeyUncompressed";
    AuthFieldType[AuthFieldType["SignatureCompressed"] = 2] = "SignatureCompressed";
    AuthFieldType[AuthFieldType["SignatureUncompressed"] = 3] = "SignatureUncompressed";
})(AuthFieldType || (AuthFieldType = {}));
function deserializeMessageSignature(bytesReader) {
    return createMessageSignature(bytesToHex(bytesReader.readBytes(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)));
}
function createTransactionAuthField(pubKeyEncoding, contents) {
    return {
        pubKeyEncoding,
        type: StacksMessageType.TransactionAuthField,
        contents,
    };
}
function deserializeTransactionAuthField(bytesReader) {
    const authFieldType = bytesReader.readUInt8Enum(AuthFieldType, n => {
        throw new DeserializationError(`Could not read ${n} as AuthFieldType`);
    });
    switch (authFieldType) {
        case AuthFieldType.PublicKeyCompressed:
            return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bytesReader));
        case AuthFieldType.PublicKeyUncompressed:
            return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bytesReader));
        case AuthFieldType.SignatureCompressed:
            return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bytesReader));
        case AuthFieldType.SignatureUncompressed:
            return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bytesReader));
        default:
            throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);
    }
}
function serializeMessageSignature(messageSignature) {
    return hexToBytes(messageSignature.data);
}
function serializeTransactionAuthField(field) {
    const bytesArray = [];
    switch (field.contents.type) {
        case StacksMessageType.PublicKey:
            if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {
                bytesArray.push(AuthFieldType.PublicKeyCompressed);
                bytesArray.push(serializePublicKey(field.contents));
            }
            else {
                bytesArray.push(AuthFieldType.PublicKeyUncompressed);
                bytesArray.push(serializePublicKey(compressPublicKey(field.contents.data)));
            }
            break;
        case StacksMessageType.MessageSignature:
            if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {
                bytesArray.push(AuthFieldType.SignatureCompressed);
            }
            else {
                bytesArray.push(AuthFieldType.SignatureUncompressed);
            }
            bytesArray.push(serializeMessageSignature(field.contents));
            break;
    }
    return concatArray(bytesArray);
}

function serializeStacksMessage(message) {
    switch (message.type) {
        case StacksMessageType.Address:
            return serializeAddress(message);
        case StacksMessageType.Principal:
            return serializePrincipal(message);
        case StacksMessageType.LengthPrefixedString:
            return serializeLPString(message);
        case StacksMessageType.MemoString:
            return serializeMemoString(message);
        case StacksMessageType.AssetInfo:
            return serializeAssetInfo(message);
        case StacksMessageType.PostCondition:
            return serializePostCondition(message);
        case StacksMessageType.PublicKey:
            return serializePublicKey(message);
        case StacksMessageType.LengthPrefixedList:
            return serializeLPList(message);
        case StacksMessageType.Payload:
            return serializePayload(message);
        case StacksMessageType.TransactionAuthField:
            return serializeTransactionAuthField(message);
        case StacksMessageType.MessageSignature:
            return serializeMessageSignature(message);
    }
}
function deserializeStacksMessage(bytesReader, type, listType) {
    switch (type) {
        case StacksMessageType.Address:
            return deserializeAddress(bytesReader);
        case StacksMessageType.Principal:
            return deserializePrincipal(bytesReader);
        case StacksMessageType.LengthPrefixedString:
            return deserializeLPString(bytesReader);
        case StacksMessageType.MemoString:
            return deserializeMemoString(bytesReader);
        case StacksMessageType.AssetInfo:
            return deserializeAssetInfo(bytesReader);
        case StacksMessageType.PostCondition:
            return deserializePostCondition(bytesReader);
        case StacksMessageType.PublicKey:
            return deserializePublicKey(bytesReader);
        case StacksMessageType.Payload:
            return deserializePayload(bytesReader);
        case StacksMessageType.LengthPrefixedList:
            if (!listType) {
                throw new DeserializationError('No List Type specified');
            }
            return deserializeLPList(bytesReader, listType);
        case StacksMessageType.MessageSignature:
            return deserializeMessageSignature(bytesReader);
        default:
            throw new Error('Could not recognize StacksMessageType');
    }
}
function createEmptyAddress() {
    return {
        type: StacksMessageType.Address,
        version: AddressVersion.MainnetSingleSig,
        hash160: '0'.repeat(40),
    };
}
function addressFromHashMode(hashMode, txVersion, data) {
    const version = addressHashModeToVersion(hashMode, txVersion);
    return addressFromVersionHash(version, data);
}
function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {
    if (publicKeys.length === 0) {
        throw Error('Invalid number of public keys');
    }
    if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {
        if (publicKeys.length !== 1 || numSigs !== 1) {
            throw Error('Invalid number of public keys or signatures');
        }
    }
    if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {
        for (let i = 0; i < publicKeys.length; i++) {
            if (!isCompressed(publicKeys[i])) {
                throw Error('Public keys must be compressed for segwit');
            }
        }
    }
    switch (hashMode) {
        case AddressHashMode.SerializeP2PKH:
            return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));
        case AddressHashMode.SerializeP2WPKH:
            return addressFromVersionHash(version, hashP2WPKH(publicKeys[0].data));
        case AddressHashMode.SerializeP2SH:
            return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));
        case AddressHashMode.SerializeP2WSH:
            return addressFromVersionHash(version, hashP2WSH(numSigs, publicKeys.map(serializePublicKey)));
    }
}
function serializeAddress(address) {
    const bytesArray = [];
    bytesArray.push(hexToBytes(intToHex(address.version, 1)));
    bytesArray.push(hexToBytes(address.hash160));
    return concatArray(bytesArray);
}
function deserializeAddress(bytesReader) {
    const version = hexToInt(bytesToHex(bytesReader.readBytes(1)));
    const data = bytesToHex(bytesReader.readBytes(20));
    return { type: StacksMessageType.Address, version, hash160: data };
}
function serializePrincipal(principal) {
    const bytesArray = [];
    bytesArray.push(principal.prefix);
    bytesArray.push(serializeAddress(principal.address));
    if (principal.prefix === PostConditionPrincipalID.Contract) {
        bytesArray.push(serializeLPString(principal.contractName));
    }
    return concatArray(bytesArray);
}
function deserializePrincipal(bytesReader) {
    const prefix = bytesReader.readUInt8Enum(PostConditionPrincipalID, n => {
        throw new DeserializationError(`Unexpected Principal payload type: ${n}`);
    });
    const address = deserializeAddress(bytesReader);
    if (prefix === PostConditionPrincipalID.Standard) {
        return { type: StacksMessageType.Principal, prefix, address };
    }
    const contractName = deserializeLPString(bytesReader);
    return {
        type: StacksMessageType.Principal,
        prefix,
        address,
        contractName,
    };
}
function serializeLPString(lps) {
    const bytesArray = [];
    const contentBytes = utf8ToBytes(lps.content);
    const length = contentBytes.byteLength;
    bytesArray.push(hexToBytes(intToHex(length, lps.lengthPrefixBytes)));
    bytesArray.push(contentBytes);
    return concatArray(bytesArray);
}
function deserializeLPString(bytesReader, prefixBytes, maxLength) {
    prefixBytes = prefixBytes ? prefixBytes : 1;
    const length = hexToInt(bytesToHex(bytesReader.readBytes(prefixBytes)));
    const content = bytesToUtf8(bytesReader.readBytes(length));
    return createLPString(content, prefixBytes, maxLength ?? 128);
}
function codeBodyString(content) {
    return createLPString(content, 4, 100000);
}
function createMemoString(content) {
    if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {
        throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES} bytes`);
    }
    return { type: StacksMessageType.MemoString, content };
}
function serializeMemoString(memoString) {
    const bytesArray = [];
    const contentBytes = utf8ToBytes(memoString.content);
    const paddedContent = rightPadHexToLength(bytesToHex(contentBytes), MEMO_MAX_LENGTH_BYTES * 2);
    bytesArray.push(hexToBytes(paddedContent));
    return concatArray(bytesArray);
}
function deserializeMemoString(bytesReader) {
    const content = bytesToUtf8(bytesReader.readBytes(MEMO_MAX_LENGTH_BYTES));
    return { type: StacksMessageType.MemoString, content };
}
function serializeAssetInfo(info) {
    const bytesArray = [];
    bytesArray.push(serializeAddress(info.address));
    bytesArray.push(serializeLPString(info.contractName));
    bytesArray.push(serializeLPString(info.assetName));
    return concatArray(bytesArray);
}
function deserializeAssetInfo(bytesReader) {
    return {
        type: StacksMessageType.AssetInfo,
        address: deserializeAddress(bytesReader),
        contractName: deserializeLPString(bytesReader),
        assetName: deserializeLPString(bytesReader),
    };
}
function createLPList(values, lengthPrefixBytes) {
    return {
        type: StacksMessageType.LengthPrefixedList,
        lengthPrefixBytes: lengthPrefixBytes || 4,
        values,
    };
}
function serializeLPList(lpList) {
    const list = lpList.values;
    const bytesArray = [];
    bytesArray.push(hexToBytes(intToHex(list.length, lpList.lengthPrefixBytes)));
    for (const l of list) {
        bytesArray.push(serializeStacksMessage(l));
    }
    return concatArray(bytesArray);
}
function deserializeLPList(bytesReader, type, lengthPrefixBytes) {
    const length = hexToInt(bytesToHex(bytesReader.readBytes(lengthPrefixBytes || 4)));
    const l = [];
    for (let index = 0; index < length; index++) {
        switch (type) {
            case StacksMessageType.Address:
                l.push(deserializeAddress(bytesReader));
                break;
            case StacksMessageType.LengthPrefixedString:
                l.push(deserializeLPString(bytesReader));
                break;
            case StacksMessageType.MemoString:
                l.push(deserializeMemoString(bytesReader));
                break;
            case StacksMessageType.AssetInfo:
                l.push(deserializeAssetInfo(bytesReader));
                break;
            case StacksMessageType.PostCondition:
                l.push(deserializePostCondition(bytesReader));
                break;
            case StacksMessageType.PublicKey:
                l.push(deserializePublicKey(bytesReader));
                break;
            case StacksMessageType.TransactionAuthField:
                l.push(deserializeTransactionAuthField(bytesReader));
                break;
        }
    }
    return createLPList(l, lengthPrefixBytes);
}
function serializePostCondition(postCondition) {
    const bytesArray = [];
    bytesArray.push(postCondition.conditionType);
    bytesArray.push(serializePrincipal(postCondition.principal));
    if (postCondition.conditionType === PostConditionType.Fungible ||
        postCondition.conditionType === PostConditionType.NonFungible) {
        bytesArray.push(serializeAssetInfo(postCondition.assetInfo));
    }
    if (postCondition.conditionType === PostConditionType.NonFungible) {
        bytesArray.push(serializeCV(postCondition.assetName));
    }
    bytesArray.push(postCondition.conditionCode);
    if (postCondition.conditionType === PostConditionType.STX ||
        postCondition.conditionType === PostConditionType.Fungible) {
        bytesArray.push(intToBytes(postCondition.amount, false, 8));
    }
    return concatArray(bytesArray);
}
function deserializePostCondition(bytesReader) {
    const postConditionType = bytesReader.readUInt8Enum(PostConditionType, n => {
        throw new DeserializationError(`Could not read ${n} as PostConditionType`);
    });
    const principal = deserializePrincipal(bytesReader);
    let conditionCode;
    let assetInfo;
    let amount;
    switch (postConditionType) {
        case PostConditionType.STX:
            conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, n => {
                throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
            return {
                type: StacksMessageType.PostCondition,
                conditionType: PostConditionType.STX,
                principal,
                conditionCode,
                amount,
            };
        case PostConditionType.Fungible:
            assetInfo = deserializeAssetInfo(bytesReader);
            conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, n => {
                throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
            return {
                type: StacksMessageType.PostCondition,
                conditionType: PostConditionType.Fungible,
                principal,
                conditionCode,
                amount,
                assetInfo,
            };
        case PostConditionType.NonFungible:
            assetInfo = deserializeAssetInfo(bytesReader);
            const assetName = deserializeCV(bytesReader);
            conditionCode = bytesReader.readUInt8Enum(NonFungibleConditionCode, n => {
                throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            return {
                type: StacksMessageType.PostCondition,
                conditionType: PostConditionType.NonFungible,
                principal,
                conditionCode,
                assetInfo,
                assetName,
            };
    }
}

function bytesWithTypeID(typeId, bytes) {
    return concatArray([typeId, bytes]);
}
function serializeBoolCV(value) {
    return new Uint8Array([value.type]);
}
function serializeOptionalCV(cv) {
    if (cv.type === ClarityType.OptionalNone) {
        return new Uint8Array([cv.type]);
    }
    else {
        return bytesWithTypeID(cv.type, serializeCV(cv.value));
    }
}
function serializeBufferCV(cv) {
    const length = new Uint8Array(4);
    writeUInt32BE(length, cv.buffer.length, 0);
    return bytesWithTypeID(cv.type, concatBytes(length, cv.buffer));
}
function serializeIntCV(cv) {
    const bytes = bigIntToBytes(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);
    return bytesWithTypeID(cv.type, bytes);
}
function serializeUIntCV(cv) {
    const bytes = bigIntToBytes(cv.value, CLARITY_INT_BYTE_SIZE);
    return bytesWithTypeID(cv.type, bytes);
}
function serializeStandardPrincipalCV(cv) {
    return bytesWithTypeID(cv.type, serializeAddress(cv.address));
}
function serializeContractPrincipalCV(cv) {
    return bytesWithTypeID(cv.type, concatBytes(serializeAddress(cv.address), serializeLPString(cv.contractName)));
}
function serializeResponseCV(cv) {
    return bytesWithTypeID(cv.type, serializeCV(cv.value));
}
function serializeListCV(cv) {
    const bytesArray = [];
    const length = new Uint8Array(4);
    writeUInt32BE(length, cv.list.length, 0);
    bytesArray.push(length);
    for (const value of cv.list) {
        const serializedValue = serializeCV(value);
        bytesArray.push(serializedValue);
    }
    return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeTupleCV(cv) {
    const bytesArray = [];
    const length = new Uint8Array(4);
    writeUInt32BE(length, Object.keys(cv.data).length, 0);
    bytesArray.push(length);
    const lexicographicOrder = Object.keys(cv.data).sort((a, b) => a.localeCompare(b));
    for (const key of lexicographicOrder) {
        const nameWithLength = createLPString(key);
        bytesArray.push(serializeLPString(nameWithLength));
        const serializedValue = serializeCV(cv.data[key]);
        bytesArray.push(serializedValue);
    }
    return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeStringCV(cv, encoding) {
    const bytesArray = [];
    const str = encoding == 'ascii' ? asciiToBytes(cv.data) : utf8ToBytes(cv.data);
    const len = new Uint8Array(4);
    writeUInt32BE(len, str.length, 0);
    bytesArray.push(len);
    bytesArray.push(str);
    return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeStringAsciiCV(cv) {
    return serializeStringCV(cv, 'ascii');
}
function serializeStringUtf8CV(cv) {
    return serializeStringCV(cv, 'utf8');
}
function serializeCV(value) {
    switch (value.type) {
        case ClarityType.BoolTrue:
        case ClarityType.BoolFalse:
            return serializeBoolCV(value);
        case ClarityType.OptionalNone:
        case ClarityType.OptionalSome:
            return serializeOptionalCV(value);
        case ClarityType.Buffer:
            return serializeBufferCV(value);
        case ClarityType.UInt:
            return serializeUIntCV(value);
        case ClarityType.Int:
            return serializeIntCV(value);
        case ClarityType.PrincipalStandard:
            return serializeStandardPrincipalCV(value);
        case ClarityType.PrincipalContract:
            return serializeContractPrincipalCV(value);
        case ClarityType.ResponseOk:
        case ClarityType.ResponseErr:
            return serializeResponseCV(value);
        case ClarityType.List:
            return serializeListCV(value);
        case ClarityType.Tuple:
            return serializeTupleCV(value);
        case ClarityType.StringASCII:
            return serializeStringAsciiCV(value);
        case ClarityType.StringUTF8:
            return serializeStringUtf8CV(value);
        default:
            throw new SerializationError('Unable to serialize. Invalid Clarity Value.');
    }
}

function createEnumChecker(enumVariable) {
    const enumValues = Object.values(enumVariable).filter(v => typeof v === 'number');
    const enumValueSet = new Set(enumValues);
    return (value) => enumValueSet.has(value);
}
const enumCheckFunctions = new Map();
function isEnum(enumVariable, value) {
    const checker = enumCheckFunctions.get(enumVariable);
    if (checker !== undefined) {
        return checker(value);
    }
    const newChecker = createEnumChecker(enumVariable);
    enumCheckFunctions.set(enumVariable, newChecker);
    return isEnum(enumVariable, value);
}
class BytesReader {
    constructor(arr) {
        this.consumed = 0;
        this.source = arr;
    }
    readBytes(length) {
        const view = this.source.subarray(this.consumed, this.consumed + length);
        this.consumed += length;
        return view;
    }
    readUInt32BE() {
        return readUInt32BE(this.readBytes(4), 0);
    }
    readUInt8() {
        return readUInt8(this.readBytes(1), 0);
    }
    readUInt16BE() {
        return readUInt16BE(this.readBytes(2), 0);
    }
    readBigUIntLE(length) {
        const bytes = this.readBytes(length).slice().reverse();
        const hex = bytesToHex(bytes);
        return BigInt(`0x${hex}`);
    }
    readBigUIntBE(length) {
        const bytes = this.readBytes(length);
        const hex = bytesToHex(bytes);
        return BigInt(`0x${hex}`);
    }
    get readOffset() {
        return this.consumed;
    }
    set readOffset(val) {
        this.consumed = val;
    }
    get internalBytes() {
        return this.source;
    }
    readUInt8Enum(enumVariable, invalidEnumErrorFormatter) {
        const num = this.readUInt8();
        if (isEnum(enumVariable, num)) {
            return num;
        }
        throw invalidEnumErrorFormatter(num);
    }
}

function deserializeCV(serializedClarityValue) {
    let bytesReader;
    if (typeof serializedClarityValue === 'string') {
        const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';
        bytesReader = new BytesReader(hexToBytes(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue));
    }
    else if (serializedClarityValue instanceof Uint8Array) {
        bytesReader = new BytesReader(serializedClarityValue);
    }
    else {
        bytesReader = serializedClarityValue;
    }
    const type = bytesReader.readUInt8Enum(ClarityType, n => {
        throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);
    });
    switch (type) {
        case ClarityType.Int:
            return intCV(bytesReader.readBytes(16));
        case ClarityType.UInt:
            return uintCV(bytesReader.readBytes(16));
        case ClarityType.Buffer:
            const bufferLength = bytesReader.readUInt32BE();
            return bufferCV(bytesReader.readBytes(bufferLength));
        case ClarityType.BoolTrue:
            return trueCV();
        case ClarityType.BoolFalse:
            return falseCV();
        case ClarityType.PrincipalStandard:
            const sAddress = deserializeAddress(bytesReader);
            return standardPrincipalCVFromAddress(sAddress);
        case ClarityType.PrincipalContract:
            const cAddress = deserializeAddress(bytesReader);
            const contractName = deserializeLPString(bytesReader);
            return contractPrincipalCVFromAddress(cAddress, contractName);
        case ClarityType.ResponseOk:
            return responseOkCV(deserializeCV(bytesReader));
        case ClarityType.ResponseErr:
            return responseErrorCV(deserializeCV(bytesReader));
        case ClarityType.OptionalNone:
            return noneCV();
        case ClarityType.OptionalSome:
            return someCV(deserializeCV(bytesReader));
        case ClarityType.List:
            const listLength = bytesReader.readUInt32BE();
            const listContents = [];
            for (let i = 0; i < listLength; i++) {
                listContents.push(deserializeCV(bytesReader));
            }
            return listCV(listContents);
        case ClarityType.Tuple:
            const tupleLength = bytesReader.readUInt32BE();
            const tupleContents = {};
            for (let i = 0; i < tupleLength; i++) {
                const clarityName = deserializeLPString(bytesReader).content;
                if (clarityName === undefined) {
                    throw new DeserializationError('"content" is undefined');
                }
                tupleContents[clarityName] = deserializeCV(bytesReader);
            }
            return tupleCV(tupleContents);
        case ClarityType.StringASCII:
            const asciiStrLen = bytesReader.readUInt32BE();
            const asciiStr = bytesToAscii(bytesReader.readBytes(asciiStrLen));
            return stringAsciiCV(asciiStr);
        case ClarityType.StringUTF8:
            const utf8StrLen = bytesReader.readUInt32BE();
            const utf8Str = bytesToUtf8(bytesReader.readBytes(utf8StrLen));
            return stringUtf8CV(utf8Str);
        default:
            throw new DeserializationError('Unable to deserialize Clarity Value from Uint8Array. Could not find valid Clarity Type.');
    }
}

const randomBytes = (bytesLength) => utils.randomBytes(bytesLength);
const leftPadHex = (hexString) => hexString.length % 2 == 0 ? hexString : `0${hexString}`;
const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');
const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');
const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? utf8ToBytes(string).length > maxLengthBytes : false;
function cloneDeep(obj) {
    return lodashCloneDeep(obj);
}
function omit(obj, prop) {
    const clone = cloneDeep(obj);
    delete clone[prop];
    return clone;
}
const txidFromData = (data) => {
    return bytesToHex(sha512_256(data));
};
const hash160 = (input) => {
    return ripemd160(sha256(input));
};
const hashP2PKH = (input) => {
    return bytesToHex(hash160(input));
};
const hashP2WPKH = (input) => {
    const keyHash = hash160(input);
    const redeemScript = concatBytes(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);
    const redeemScriptHash = hash160(redeemScript);
    return bytesToHex(redeemScriptHash);
};
const hashP2SH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2SH multisig address can only contain up to 15 public keys');
    }
    const bytesArray = [];
    bytesArray.push(80 + numSigs);
    pubKeys.forEach(pubKey => {
        bytesArray.push(pubKey.length);
        bytesArray.push(pubKey);
    });
    bytesArray.push(80 + pubKeys.length);
    bytesArray.push(174);
    const redeemScript = concatArray(bytesArray);
    const redeemScriptHash = hash160(redeemScript);
    return bytesToHex(redeemScriptHash);
};
const hashP2WSH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2WSH multisig address can only contain up to 15 public keys');
    }
    const scriptArray = [];
    scriptArray.push(80 + numSigs);
    pubKeys.forEach(pubKey => {
        scriptArray.push(pubKey.length);
        scriptArray.push(pubKey);
    });
    scriptArray.push(80 + pubKeys.length);
    scriptArray.push(174);
    const script = concatArray(scriptArray);
    const digest = sha256(script);
    const bytesArray = [];
    bytesArray.push(0);
    bytesArray.push(digest.length);
    bytesArray.push(digest);
    const redeemScript = concatArray(bytesArray);
    const redeemScriptHash = hash160(redeemScript);
    return bytesToHex(redeemScriptHash);
};
function isClarityName(name) {
    const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;
    return regex.test(name) && name.length < 128;
}
function cvToHex(cv) {
    const serialized = serializeCV(cv);
    return `0x${bytesToHex(serialized)}`;
}
function hexToCV(hex) {
    return deserializeCV(hex);
}
const parseReadOnlyResponse = (response) => {
    if (response.okay)
        return hexToCV(response.result);
    throw new Error(response.cause);
};
const validateStacksAddress = (stacksAddress) => {
    try {
        c32addressDecode(stacksAddress);
        return true;
    }
    catch (e) {
        return false;
    }
};
const validateTxId = (txid) => {
    if (txid === 'success')
        return true;
    const value = with0x(txid).toLowerCase();
    if (value.length !== 66)
        return false;
    return with0x(BigInt(value).toString(16).padStart(64, '0')) === value;
};

function emptyMessageSignature() {
    return {
        type: StacksMessageType.MessageSignature,
        data: bytesToHex(new Uint8Array(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)),
    };
}
function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {
    const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;
    const keyEncoding = isCompressed(createStacksPublicKey(pubKey))
        ? PubKeyEncoding.Compressed
        : PubKeyEncoding.Uncompressed;
    return {
        hashMode,
        signer,
        nonce: intToBigInt(nonce, false),
        fee: intToBigInt(fee, false),
        keyEncoding,
        signature: emptyMessageSignature(),
    };
}
function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {
    const stacksPublicKeys = pubKeys.map(createStacksPublicKey);
    const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;
    return {
        hashMode,
        signer,
        nonce: intToBigInt(nonce, false),
        fee: intToBigInt(fee, false),
        fields: [],
        signaturesRequired: numSigs,
    };
}
function isSingleSig(condition) {
    return 'signature' in condition;
}
function clearCondition(condition) {
    const cloned = cloneDeep(condition);
    cloned.nonce = 0;
    cloned.fee = 0;
    if (isSingleSig(cloned)) {
        cloned.signature = emptyMessageSignature();
    }
    else {
        cloned.fields = [];
    }
    return {
        ...cloned,
        nonce: BigInt(0),
        fee: BigInt(0),
    };
}
function serializeSingleSigSpendingCondition(condition) {
    const bytesArray = [
        condition.hashMode,
        hexToBytes(condition.signer),
        intToBytes(condition.nonce, false, 8),
        intToBytes(condition.fee, false, 8),
        condition.keyEncoding,
        serializeMessageSignature(condition.signature),
    ];
    return concatArray(bytesArray);
}
function serializeMultiSigSpendingCondition(condition) {
    const bytesArray = [
        condition.hashMode,
        hexToBytes(condition.signer),
        intToBytes(condition.nonce, false, 8),
        intToBytes(condition.fee, false, 8),
    ];
    const fields = createLPList(condition.fields);
    bytesArray.push(serializeLPList(fields));
    const numSigs = new Uint8Array(2);
    writeUInt16BE(numSigs, condition.signaturesRequired, 0);
    bytesArray.push(numSigs);
    return concatArray(bytesArray);
}
function deserializeSingleSigSpendingCondition(hashMode, bytesReader) {
    const signer = bytesToHex(bytesReader.readBytes(20));
    const nonce = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
    const fee = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
    const keyEncoding = bytesReader.readUInt8Enum(PubKeyEncoding, n => {
        throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);
    });
    if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {
        throw new DeserializationError('Failed to parse singlesig spending condition: incomaptible hash mode and key encoding');
    }
    const signature = deserializeMessageSignature(bytesReader);
    return {
        hashMode,
        signer,
        nonce,
        fee,
        keyEncoding,
        signature,
    };
}
function deserializeMultiSigSpendingCondition(hashMode, bytesReader) {
    const signer = bytesToHex(bytesReader.readBytes(20));
    const nonce = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));
    const fee = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));
    const fields = deserializeLPList(bytesReader, StacksMessageType.TransactionAuthField)
        .values;
    let haveUncompressed = false;
    let numSigs = 0;
    for (const field of fields) {
        switch (field.contents.type) {
            case StacksMessageType.PublicKey:
                if (!isCompressed(field.contents))
                    haveUncompressed = true;
                break;
            case StacksMessageType.MessageSignature:
                if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed)
                    haveUncompressed = true;
                numSigs += 1;
                if (numSigs === 65536)
                    throw new VerificationError('Failed to parse multisig spending condition: too many signatures');
                break;
        }
    }
    const signaturesRequired = bytesReader.readUInt16BE();
    if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH)
        throw new VerificationError('Uncompressed keys are not allowed in this hash mode');
    return {
        hashMode,
        signer,
        nonce,
        fee,
        fields,
        signaturesRequired,
    };
}
function serializeSpendingCondition(condition) {
    if (isSingleSig(condition)) {
        return serializeSingleSigSpendingCondition(condition);
    }
    return serializeMultiSigSpendingCondition(condition);
}
function deserializeSpendingCondition(bytesReader) {
    const hashMode = bytesReader.readUInt8Enum(AddressHashMode, n => {
        throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);
    });
    if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {
        return deserializeSingleSigSpendingCondition(hashMode, bytesReader);
    }
    else {
        return deserializeMultiSigSpendingCondition(hashMode, bytesReader);
    }
}
function makeSigHashPreSign(curSigHash, authType, fee, nonce) {
    const hashLength = 32 + 1 + 8 + 8;
    const sigHash = curSigHash +
        bytesToHex(new Uint8Array([authType])) +
        bytesToHex(intToBytes(fee, false, 8)) +
        bytesToHex(intToBytes(nonce, false, 8));
    if (hexToBytes(sigHash).byteLength !== hashLength) {
        throw Error('Invalid signature hash length');
    }
    return txidFromData(hexToBytes(sigHash));
}
function makeSigHashPostSign(curSigHash, pubKey, signature) {
    const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
    const pubKeyEncoding = isCompressed(pubKey)
        ? PubKeyEncoding.Compressed
        : PubKeyEncoding.Uncompressed;
    const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;
    const sigHashBytes = hexToBytes(sigHash);
    if (sigHashBytes.byteLength > hashLength) {
        throw Error('Invalid signature hash length');
    }
    return txidFromData(sigHashBytes);
}
function nextSignature(curSigHash, authType, fee, nonce, privateKey) {
    const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);
    const signature = signWithKey(privateKey, sigHashPreSign);
    const publicKey = getPublicKey(privateKey);
    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
    return {
        nextSig: signature,
        nextSigHash,
    };
}
function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {
    const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);
    const publicKey = createStacksPublicKey(publicKeyFromSignatureVrs(sigHashPreSign, signature, pubKeyEncoding));
    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
    return {
        pubKey: publicKey,
        nextSigHash,
    };
}
function newInitialSigHash() {
    const spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', 0, 0);
    spendingCondition.signer = createEmptyAddress().hash160;
    spendingCondition.keyEncoding = PubKeyEncoding.Compressed;
    spendingCondition.signature = emptyMessageSignature();
    return spendingCondition;
}
function verify(condition, initialSigHash, authType) {
    if (isSingleSig(condition)) {
        return verifySingleSig(condition, initialSigHash, authType);
    }
    else {
        return verifyMultiSig(condition, initialSigHash, authType);
    }
}
function verifySingleSig(condition, initialSigHash, authType) {
    const { pubKey, nextSigHash } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);
    const addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;
    if (addrBytes !== condition.signer)
        throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);
    return nextSigHash;
}
function verifyMultiSig(condition, initialSigHash, authType) {
    const publicKeys = [];
    let curSigHash = initialSigHash;
    let haveUncompressed = false;
    let numSigs = 0;
    for (const field of condition.fields) {
        let foundPubKey;
        switch (field.contents.type) {
            case StacksMessageType.PublicKey:
                if (!isCompressed(field.contents))
                    haveUncompressed = true;
                foundPubKey = field.contents;
                break;
            case StacksMessageType.MessageSignature:
                if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed)
                    haveUncompressed = true;
                const { pubKey, nextSigHash } = nextVerification(curSigHash, authType, condition.fee, condition.nonce, field.pubKeyEncoding, field.contents);
                curSigHash = nextSigHash;
                foundPubKey = pubKey;
                numSigs += 1;
                if (numSigs === 65536)
                    throw new VerificationError('Too many signatures');
                break;
        }
        publicKeys.push(foundPubKey);
    }
    if (numSigs !== condition.signaturesRequired)
        throw new VerificationError('Incorrect number of signatures');
    if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH)
        throw new VerificationError('Uncompressed keys are not allowed in this hash mode');
    const addrBytes = addressFromPublicKeys(0, condition.hashMode, condition.signaturesRequired, publicKeys).hash160;
    if (addrBytes !== condition.signer)
        throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);
    return curSigHash;
}
function createStandardAuth(spendingCondition) {
    return {
        authType: AuthType.Standard,
        spendingCondition,
    };
}
function createSponsoredAuth(spendingCondition, sponsorSpendingCondition) {
    return {
        authType: AuthType.Sponsored,
        spendingCondition,
        sponsorSpendingCondition: sponsorSpendingCondition
            ? sponsorSpendingCondition
            : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0),
    };
}
function intoInitialSighashAuth(auth) {
    if (auth.spendingCondition) {
        switch (auth.authType) {
            case AuthType.Standard:
                return createStandardAuth(clearCondition(auth.spendingCondition));
            case AuthType.Sponsored:
                return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());
            default:
                throw new SigningError('Unexpected authorization type for signing');
        }
    }
    throw new Error('Authorization missing SpendingCondition');
}
function verifyOrigin(auth, initialSigHash) {
    switch (auth.authType) {
        case AuthType.Standard:
            return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);
        case AuthType.Sponsored:
            return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);
        default:
            throw new SigningError('Invalid origin auth type');
    }
}
function setFee(auth, amount) {
    switch (auth.authType) {
        case AuthType.Standard:
            const spendingCondition = {
                ...auth.spendingCondition,
                fee: intToBigInt(amount, false),
            };
            return { ...auth, spendingCondition };
        case AuthType.Sponsored:
            const sponsorSpendingCondition = {
                ...auth.sponsorSpendingCondition,
                fee: intToBigInt(amount, false),
            };
            return { ...auth, sponsorSpendingCondition };
    }
}
function getFee(auth) {
    switch (auth.authType) {
        case AuthType.Standard:
            return auth.spendingCondition.fee;
        case AuthType.Sponsored:
            return auth.sponsorSpendingCondition.fee;
    }
}
function setNonce(auth, nonce) {
    const spendingCondition = {
        ...auth.spendingCondition,
        nonce: intToBigInt(nonce, false),
    };
    return {
        ...auth,
        spendingCondition,
    };
}
function setSponsorNonce(auth, nonce) {
    const sponsorSpendingCondition = {
        ...auth.sponsorSpendingCondition,
        nonce: intToBigInt(nonce, false),
    };
    return {
        ...auth,
        sponsorSpendingCondition,
    };
}
function setSponsor(auth, sponsorSpendingCondition) {
    const sc = {
        ...sponsorSpendingCondition,
        nonce: intToBigInt(sponsorSpendingCondition.nonce, false),
        fee: intToBigInt(sponsorSpendingCondition.fee, false),
    };
    return {
        ...auth,
        sponsorSpendingCondition: sc,
    };
}
function serializeAuthorization(auth) {
    const bytesArray = [];
    bytesArray.push(auth.authType);
    switch (auth.authType) {
        case AuthType.Standard:
            bytesArray.push(serializeSpendingCondition(auth.spendingCondition));
            break;
        case AuthType.Sponsored:
            bytesArray.push(serializeSpendingCondition(auth.spendingCondition));
            bytesArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));
            break;
    }
    return concatArray(bytesArray);
}
function deserializeAuthorization(bytesReader) {
    const authType = bytesReader.readUInt8Enum(AuthType, n => {
        throw new DeserializationError(`Could not parse ${n} as AuthType`);
    });
    let spendingCondition;
    switch (authType) {
        case AuthType.Standard:
            spendingCondition = deserializeSpendingCondition(bytesReader);
            return createStandardAuth(spendingCondition);
        case AuthType.Sponsored:
            spendingCondition = deserializeSpendingCondition(bytesReader);
            const sponsorSpendingCondition = deserializeSpendingCondition(bytesReader);
            return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);
    }
}

var ClarityAbiTypeId;
(function (ClarityAbiTypeId) {
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeUInt128"] = 1] = "ClarityAbiTypeUInt128";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeInt128"] = 2] = "ClarityAbiTypeInt128";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeBool"] = 3] = "ClarityAbiTypeBool";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypePrincipal"] = 4] = "ClarityAbiTypePrincipal";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeNone"] = 5] = "ClarityAbiTypeNone";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeBuffer"] = 6] = "ClarityAbiTypeBuffer";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeResponse"] = 7] = "ClarityAbiTypeResponse";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeOptional"] = 8] = "ClarityAbiTypeOptional";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeTuple"] = 9] = "ClarityAbiTypeTuple";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeList"] = 10] = "ClarityAbiTypeList";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeStringAscii"] = 11] = "ClarityAbiTypeStringAscii";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeStringUtf8"] = 12] = "ClarityAbiTypeStringUtf8";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeTraitReference"] = 13] = "ClarityAbiTypeTraitReference";
})(ClarityAbiTypeId || (ClarityAbiTypeId = {}));
const isClarityAbiPrimitive = (val) => typeof val === 'string';
const isClarityAbiBuffer = (val) => val.buffer !== undefined;
const isClarityAbiStringAscii = (val) => val['string-ascii'] !== undefined;
const isClarityAbiStringUtf8 = (val) => val['string-utf8'] !== undefined;
const isClarityAbiResponse = (val) => val.response !== undefined;
const isClarityAbiOptional = (val) => val.optional !== undefined;
const isClarityAbiTuple = (val) => val.tuple !== undefined;
const isClarityAbiList = (val) => val.list !== undefined;
function getTypeUnion(val) {
    if (isClarityAbiPrimitive(val)) {
        if (val === 'uint128') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };
        }
        else if (val === 'int128') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };
        }
        else if (val === 'bool') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };
        }
        else if (val === 'principal') {
            return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };
        }
        else if (val === 'trait_reference') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };
        }
        else if (val === 'none') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };
        }
        else {
            throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);
        }
    }
    else if (isClarityAbiBuffer(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };
    }
    else if (isClarityAbiResponse(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };
    }
    else if (isClarityAbiOptional(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };
    }
    else if (isClarityAbiTuple(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };
    }
    else if (isClarityAbiList(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };
    }
    else if (isClarityAbiStringAscii(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };
    }
    else if (isClarityAbiStringUtf8(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };
    }
    else {
        throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);
    }
}
function encodeClarityValue(input, val) {
    let union;
    if (input.id !== undefined) {
        union = input;
    }
    else {
        union = getTypeUnion(input);
    }
    switch (union.id) {
        case ClarityAbiTypeId.ClarityAbiTypeUInt128:
            return uintCV(val);
        case ClarityAbiTypeId.ClarityAbiTypeInt128:
            return intCV(val);
        case ClarityAbiTypeId.ClarityAbiTypeBool:
            if (val === 'false' || val === '0')
                return falseCV();
            else if (val === 'true' || val === '1')
                return trueCV();
            else
                throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);
        case ClarityAbiTypeId.ClarityAbiTypePrincipal:
            if (val.includes('.')) {
                const [addr, name] = val.split('.');
                return contractPrincipalCV(addr, name);
            }
            else {
                return standardPrincipalCV(val);
            }
        case ClarityAbiTypeId.ClarityAbiTypeTraitReference:
            const [addr, name] = val.split('.');
            return contractPrincipalCV(addr, name);
        case ClarityAbiTypeId.ClarityAbiTypeNone:
            return noneCV();
        case ClarityAbiTypeId.ClarityAbiTypeBuffer:
            return bufferCV(utf8ToBytes(val));
        case ClarityAbiTypeId.ClarityAbiTypeStringAscii:
            return stringAsciiCV(val);
        case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:
            return stringUtf8CV(val);
        case ClarityAbiTypeId.ClarityAbiTypeResponse:
            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeOptional:
            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeTuple:
            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeList:
            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        default:
            throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);
    }
}
function getTypeString(val) {
    if (isClarityAbiPrimitive(val)) {
        if (val === 'int128') {
            return 'int';
        }
        else if (val === 'uint128') {
            return 'uint';
        }
        return val;
    }
    else if (isClarityAbiBuffer(val)) {
        return `(buff ${val.buffer.length})`;
    }
    else if (isClarityAbiStringAscii(val)) {
        return `(string-ascii ${val['string-ascii'].length})`;
    }
    else if (isClarityAbiStringUtf8(val)) {
        return `(string-utf8 ${val['string-utf8'].length})`;
    }
    else if (isClarityAbiResponse(val)) {
        return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;
    }
    else if (isClarityAbiOptional(val)) {
        return `(optional ${getTypeString(val.optional)})`;
    }
    else if (isClarityAbiTuple(val)) {
        return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;
    }
    else if (isClarityAbiList(val)) {
        return `(list ${val.list.length} ${getTypeString(val.list.type)})`;
    }
    else {
        throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);
    }
}
function abiFunctionToString(func) {
    const access = func.access === 'read_only' ? 'read-only' : func.access;
    return `(define-${access} (${func.name} ${func.args
        .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)
        .join(' ')}))`;
}
function matchType(cv, abiType) {
    const union = getTypeUnion(abiType);
    switch (cv.type) {
        case ClarityType.BoolTrue:
        case ClarityType.BoolFalse:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;
        case ClarityType.Int:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;
        case ClarityType.UInt:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;
        case ClarityType.Buffer:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&
                union.type.buffer.length >= cv.buffer.length);
        case ClarityType.StringASCII:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&
                union.type['string-ascii'].length >= cv.data.length);
        case ClarityType.StringUTF8:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&
                union.type['string-utf8'].length >= cv.data.length);
        case ClarityType.OptionalNone:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||
                union.id === ClarityAbiTypeId.ClarityAbiTypeOptional);
        case ClarityType.OptionalSome:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&
                matchType(cv.value, union.type.optional));
        case ClarityType.ResponseErr:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&
                matchType(cv.value, union.type.response.error));
        case ClarityType.ResponseOk:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&
                matchType(cv.value, union.type.response.ok));
        case ClarityType.PrincipalContract:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||
                union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference);
        case ClarityType.PrincipalStandard:
            return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;
        case ClarityType.List:
            return (union.id == ClarityAbiTypeId.ClarityAbiTypeList &&
                union.type.list.length >= cv.list.length &&
                cv.list.every(val => matchType(val, union.type.list.type)));
        case ClarityType.Tuple:
            if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {
                const tuple = cloneDeep(cv.data);
                for (let i = 0; i < union.type.tuple.length; i++) {
                    const abiTupleEntry = union.type.tuple[i];
                    const key = abiTupleEntry.name;
                    const val = tuple[key];
                    if (val) {
                        if (!matchType(val, abiTupleEntry.type)) {
                            return false;
                        }
                        delete tuple[key];
                    }
                    else {
                        return false;
                    }
                }
                return true;
            }
            else {
                return false;
            }
        default:
            return false;
    }
}
function validateContractCall(payload, abi) {
    const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);
    if (filtered.length === 1) {
        const abiFunc = filtered[0];
        const abiArgs = abiFunc.args;
        if (payload.functionArgs.length !== abiArgs.length) {
            throw new Error(`Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`);
        }
        for (let i = 0; i < payload.functionArgs.length; i++) {
            const payloadArg = payload.functionArgs[i];
            const abiArg = abiArgs[i];
            if (!matchType(payloadArg, abiArg.type)) {
                const argNum = i + 1;
                throw new Error(`Clarity function \`${payload.functionName.content}\` expects argument ${argNum} to be of type ${getTypeString(abiArg.type)}, not ${getCVTypeString(payloadArg)}`);
            }
        }
        return true;
    }
    else if (filtered.length === 0) {
        throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);
    }
    else {
        throw new Error(`Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`);
    }
}
function parseToCV(input, type) {
    const typeString = getTypeString(type);
    if (isClarityAbiPrimitive(type)) {
        if (type === 'uint128') {
            return uintCV(input);
        }
        else if (type === 'int128') {
            return intCV(input);
        }
        else if (type === 'bool') {
            if (input.toLowerCase() === 'true') {
                return trueCV();
            }
            else if (input.toLowerCase() === 'false') {
                return falseCV();
            }
            else {
                throw new Error(`Invalid bool value: ${input}`);
            }
        }
        else if (type === 'principal') {
            if (input.includes('.')) {
                const [address, contractName] = input.split('.');
                return contractPrincipalCV(address, contractName);
            }
            else {
                return standardPrincipalCV(input);
            }
        }
        else {
            throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
        }
    }
    else if (isClarityAbiBuffer(type)) {
        const inputLength = utf8ToBytes(input).byteLength;
        if (inputLength > type.buffer.length) {
            throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);
        }
        return bufferCVFromString(input);
    }
    else if (isClarityAbiResponse(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if (isClarityAbiOptional(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if (isClarityAbiTuple(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if (isClarityAbiList(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
}

function createSTXPostCondition(principal, conditionCode, amount) {
    if (typeof principal === 'string') {
        principal = parsePrincipalString(principal);
    }
    return {
        type: StacksMessageType.PostCondition,
        conditionType: PostConditionType.STX,
        principal,
        conditionCode,
        amount: intToBigInt(amount, false),
    };
}
function createFungiblePostCondition(principal, conditionCode, amount, assetInfo) {
    if (typeof principal === 'string') {
        principal = parsePrincipalString(principal);
    }
    if (typeof assetInfo === 'string') {
        assetInfo = parseAssetInfoString(assetInfo);
    }
    return {
        type: StacksMessageType.PostCondition,
        conditionType: PostConditionType.Fungible,
        principal,
        conditionCode,
        amount: intToBigInt(amount, false),
        assetInfo,
    };
}
function createNonFungiblePostCondition(principal, conditionCode, assetInfo, assetName) {
    if (typeof principal === 'string') {
        principal = parsePrincipalString(principal);
    }
    if (typeof assetInfo === 'string') {
        assetInfo = parseAssetInfoString(assetInfo);
    }
    return {
        type: StacksMessageType.PostCondition,
        conditionType: PostConditionType.NonFungible,
        principal,
        conditionCode,
        assetInfo,
        assetName,
    };
}

class TransactionSigner {
    constructor(transaction) {
        this.transaction = transaction;
        this.sigHash = transaction.signBegin();
        this.originDone = false;
        this.checkOversign = true;
        this.checkOverlap = true;
        const spendingCondition = transaction.auth.spendingCondition;
        if (spendingCondition && !isSingleSig(spendingCondition)) {
            if (spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {
                throw new Error('SpendingCondition has more signatures than are expected');
            }
            spendingCondition.fields.forEach(field => {
                if (field.contents.type === StacksMessageType.MessageSignature) {
                    const signature = field.contents;
                    const nextVerify = nextVerification(this.sigHash, transaction.auth.authType, spendingCondition.fee, spendingCondition.nonce, PubKeyEncoding.Compressed, signature);
                    this.sigHash = nextVerify.nextSigHash;
                }
            });
        }
    }
    static createSponsorSigner(transaction, spendingCondition) {
        if (transaction.auth.authType != AuthType.Sponsored) {
            throw new SigningError('Cannot add sponsor to non-sponsored transaction');
        }
        const tx = cloneDeep(transaction);
        tx.setSponsor(spendingCondition);
        const originSigHash = tx.verifyOrigin();
        const signer = new this(tx);
        signer.originDone = true;
        signer.sigHash = originSigHash;
        signer.checkOversign = true;
        signer.checkOverlap = true;
        return signer;
    }
    signOrigin(privateKey) {
        if (this.checkOverlap && this.originDone) {
            throw new SigningError('Cannot sign origin after sponsor key');
        }
        if (this.transaction.auth === undefined) {
            throw new SigningError('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.spendingCondition === undefined) {
            throw new SigningError('"transaction.auth.spendingCondition" is undefined');
        }
        if (!isSingleSig(this.transaction.auth.spendingCondition)) {
            const spendingCondition = this.transaction.auth.spendingCondition;
            if (this.checkOversign &&
                spendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {
                throw new Error('Origin would have too many signatures');
            }
        }
        const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);
        this.sigHash = nextSighash;
    }
    appendOrigin(publicKey) {
        if (this.checkOverlap && this.originDone) {
            throw Error('Cannot append public key to origin after sponsor key');
        }
        if (this.transaction.auth === undefined) {
            throw new Error('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.spendingCondition === undefined) {
            throw new Error('"transaction.auth.spendingCondition" is undefined');
        }
        this.transaction.appendPubkey(publicKey);
    }
    signSponsor(privateKey) {
        if (this.transaction.auth === undefined) {
            throw new SigningError('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.authType !== AuthType.Sponsored) {
            throw new SigningError('"transaction.auth.authType" is not AuthType.Sponsored');
        }
        const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);
        this.sigHash = nextSighash;
        this.originDone = true;
    }
    getTxInComplete() {
        return cloneDeep(this.transaction);
    }
    resume(transaction) {
        this.transaction = cloneDeep(transaction);
        this.sigHash = transaction.signBegin();
    }
}

class StacksTransaction {
    constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {
        this.version = version;
        this.auth = auth;
        if ('amount' in payload) {
            this.payload = {
                ...payload,
                amount: intToBigInt(payload.amount, false),
            };
        }
        else {
            this.payload = payload;
        }
        this.chainId = chainId ?? DEFAULT_CHAIN_ID;
        this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;
        this.postConditions = postConditions ?? createLPList([]);
        if (anchorMode) {
            this.anchorMode = anchorModeFromNameOrValue(anchorMode);
        }
        else {
            switch (payload.payloadType) {
                case PayloadType.Coinbase:
                case PayloadType.CoinbaseToAltRecipient:
                case PayloadType.PoisonMicroblock: {
                    this.anchorMode = AnchorMode.OnChainOnly;
                    break;
                }
                case PayloadType.ContractCall:
                case PayloadType.SmartContract:
                case PayloadType.VersionedSmartContract:
                case PayloadType.TokenTransfer: {
                    this.anchorMode = AnchorMode.Any;
                    break;
                }
            }
        }
    }
    signBegin() {
        const tx = cloneDeep(this);
        tx.auth = intoInitialSighashAuth(tx.auth);
        return tx.txid();
    }
    verifyBegin() {
        const tx = cloneDeep(this);
        tx.auth = intoInitialSighashAuth(tx.auth);
        return tx.txid();
    }
    verifyOrigin() {
        return verifyOrigin(this.auth, this.verifyBegin());
    }
    signNextOrigin(sigHash, privateKey) {
        if (this.auth.spendingCondition === undefined) {
            throw new Error('"auth.spendingCondition" is undefined');
        }
        if (this.auth.authType === undefined) {
            throw new Error('"auth.authType" is undefined');
        }
        return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);
    }
    signNextSponsor(sigHash, privateKey) {
        if (this.auth.authType === AuthType.Sponsored) {
            return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);
        }
        else {
            throw new Error('"auth.sponsorSpendingCondition" is undefined');
        }
    }
    appendPubkey(publicKey) {
        const cond = this.auth.spendingCondition;
        if (cond && !isSingleSig(cond)) {
            const compressed = isCompressed(publicKey);
            cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));
        }
        else {
            throw new Error(`Can't append public key to a singlesig condition`);
        }
    }
    signAndAppend(condition, curSigHash, authType, privateKey) {
        const { nextSig, nextSigHash } = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey);
        if (isSingleSig(condition)) {
            condition.signature = nextSig;
        }
        else {
            const compressed = bytesToHex(privateKey.data).endsWith('01');
            condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));
        }
        return nextSigHash;
    }
    txid() {
        const serialized = this.serialize();
        return txidFromData(serialized);
    }
    setSponsor(sponsorSpendingCondition) {
        if (this.auth.authType != AuthType.Sponsored) {
            throw new SigningError('Cannot sponsor sign a non-sponsored transaction');
        }
        this.auth = setSponsor(this.auth, sponsorSpendingCondition);
    }
    setFee(amount) {
        this.auth = setFee(this.auth, amount);
    }
    setNonce(nonce) {
        this.auth = setNonce(this.auth, nonce);
    }
    setSponsorNonce(nonce) {
        if (this.auth.authType != AuthType.Sponsored) {
            throw new SigningError('Cannot sponsor sign a non-sponsored transaction');
        }
        this.auth = setSponsorNonce(this.auth, nonce);
    }
    serialize() {
        if (this.version === undefined) {
            throw new SerializationError('"version" is undefined');
        }
        if (this.chainId === undefined) {
            throw new SerializationError('"chainId" is undefined');
        }
        if (this.auth === undefined) {
            throw new SerializationError('"auth" is undefined');
        }
        if (this.anchorMode === undefined) {
            throw new SerializationError('"anchorMode" is undefined');
        }
        if (this.payload === undefined) {
            throw new SerializationError('"payload" is undefined');
        }
        const bytesArray = [];
        bytesArray.push(this.version);
        const chainIdBytes = new Uint8Array(4);
        writeUInt32BE(chainIdBytes, this.chainId, 0);
        bytesArray.push(chainIdBytes);
        bytesArray.push(serializeAuthorization(this.auth));
        bytesArray.push(this.anchorMode);
        bytesArray.push(this.postConditionMode);
        bytesArray.push(serializeLPList(this.postConditions));
        bytesArray.push(serializePayload(this.payload));
        return concatArray(bytesArray);
    }
}
function deserializeTransaction(data) {
    let bytesReader;
    if (typeof data === 'string') {
        if (data.slice(0, 2).toLowerCase() === '0x') {
            bytesReader = new BytesReader(hexToBytes(data.slice(2)));
        }
        else {
            bytesReader = new BytesReader(hexToBytes(data));
        }
    }
    else if (data instanceof Uint8Array) {
        bytesReader = new BytesReader(data);
    }
    else {
        bytesReader = data;
    }
    const version = bytesReader.readUInt8Enum(TransactionVersion, n => {
        throw new Error(`Could not parse ${n} as TransactionVersion`);
    });
    const chainId = bytesReader.readUInt32BE();
    const auth = deserializeAuthorization(bytesReader);
    const anchorMode = bytesReader.readUInt8Enum(AnchorMode, n => {
        throw new Error(`Could not parse ${n} as AnchorMode`);
    });
    const postConditionMode = bytesReader.readUInt8Enum(PostConditionMode, n => {
        throw new Error(`Could not parse ${n} as PostConditionMode`);
    });
    const postConditions = deserializeLPList(bytesReader, StacksMessageType.PostCondition);
    const payload = deserializePayload(bytesReader);
    return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);
}

async function getNonce(address, network) {
    const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());
    const url = derivedNetwork.getAccountApiUrl(address);
    const response = await derivedNetwork.fetchFn(url);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const responseText = await response.text();
    const result = JSON.parse(responseText);
    return BigInt(result.nonce);
}
async function estimateTransfer(transaction, network) {
    if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {
        throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);
    }
    return estimateTransferUnsafe(transaction, network);
}
async function estimateTransferUnsafe(transaction, network) {
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = BigInt(transaction.serialize().byteLength);
    const feeRate = BigInt(feeRateResult);
    return feeRate * txBytes;
}
async function estimateTransaction(transactionPayload, estimatedLen, network) {
    const options = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            transaction_payload: bytesToHex(serializePayload(transactionPayload)),
            ...(estimatedLen ? { estimated_len: estimatedLen } : {}),
        }),
    };
    const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());
    const url = derivedNetwork.getTransactionFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, options);
    if (!response.ok) {
        const body = await response.json().catch(() => ({}));
        if (body?.reason === 'NoEstimateAvailable') {
            throw new NoEstimateAvailableError(body?.reason_data?.message ?? '');
        }
        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${body}"`);
    }
    const data = await response.json();
    return data.estimations;
}
async function broadcastTransaction(transaction, network, attachment) {
    const rawTx = transaction.serialize();
    const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getBroadcastApiUrl();
    return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);
}
async function broadcastRawTransaction(rawTx, url, attachment, fetchFn = createFetchFn()) {
    const options = {
        method: 'POST',
        headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },
        body: attachment
            ? JSON.stringify({
                tx: bytesToHex(rawTx),
                attachment: bytesToHex(attachment),
            })
            : rawTx,
    };
    const response = await fetchFn(url, options);
    if (!response.ok) {
        try {
            return (await response.json());
        }
        catch (e) {
            throw Error(`Failed to broadcast transaction: ${e.message}`);
        }
    }
    const text = await response.text();
    const txid = text.replace(/["]+/g, '');
    if (!validateTxId(txid))
        throw new Error(text);
    return { txid };
}
async function getAbi(address, contractName, network) {
    const options = {
        method: 'GET',
    };
    const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);
    const url = derivedNetwork.getAbiApiUrl(address, contractName);
    const response = await derivedNetwork.fetchFn(url, options);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error fetching contract ABI for contract "${contractName}" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    return JSON.parse(await response.text());
}
function deriveNetwork(transaction) {
    switch (transaction.version) {
        case TransactionVersion.Mainnet:
            return new StacksMainnet();
        case TransactionVersion.Testnet:
            return new StacksTestnet();
    }
}
async function makeUnsignedSTXTokenTransfer(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new StacksMainnet(),
        postConditionMode: PostConditionMode.Deny,
        memo: '',
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);
    let authorization = null;
    let spendingCondition = null;
    if ('publicKey' in options) {
        spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = createSponsoredAuth(spendingCondition);
    }
    else {
        authorization = createStandardAuth(spendingCondition);
    }
    const network = StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = createLPList(postConditions);
    const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const fee = await estimateTransactionFeeWithFallback(transaction, network);
        transaction.setFee(fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === TransactionVersion.Mainnet
            ? AddressVersion.MainnetSingleSig
            : AddressVersion.TestnetSingleSig;
        const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
async function makeSTXTokenTransfer(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));
        const options = omit(txOptions, 'senderKey');
        const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });
        const privKey = createStacksPrivateKey(txOptions.senderKey);
        const signer = new TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = omit(txOptions, 'signerKeys');
        const transaction = await makeUnsignedSTXTokenTransfer(options);
        const signer = new TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = pubKeyfromPrivKey(key);
            pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));
            signer.signOrigin(createStacksPrivateKey(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));
        }
        return transaction;
    }
}
async function estimateContractDeploy(transaction, network) {
    if (transaction.payload.payloadType !== PayloadType.SmartContract &&
        transaction.payload.payloadType !== PayloadType.VersionedSmartContract) {
        throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = intToBigInt(transaction.serialize().byteLength, false);
    const feeRate = intToBigInt(feeRateResult, false);
    return feeRate * txBytes;
}
async function makeContractDeploy(txOptions) {
    const privKey = createStacksPrivateKey(txOptions.senderKey);
    const stacksPublicKey = getPublicKey(privKey);
    const publicKey = publicKeyToString(stacksPublicKey);
    const unsignedTxOptions = { ...txOptions, publicKey };
    const transaction = await makeUnsignedContractDeploy(unsignedTxOptions);
    if (txOptions.senderKey) {
        const signer = new TransactionSigner(transaction);
        signer.signOrigin(privKey);
    }
    return transaction;
}
async function makeUnsignedContractDeploy(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new StacksMainnet(),
        postConditionMode: PostConditionMode.Deny,
        sponsored: false,
        clarityVersion: ClarityVersion.Clarity2,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = createSmartContractPayload(options.contractName, options.codeBody, options.clarityVersion);
    const addressHashMode = AddressHashMode.SerializeP2PKH;
    const pubKey = createStacksPublicKey(options.publicKey);
    let authorization = null;
    const spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);
    if (options.sponsored) {
        authorization = createSponsoredAuth(spendingCondition);
    }
    else {
        authorization = createStandardAuth(spendingCondition);
    }
    const network = StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = createLPList(postConditions);
    const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const fee = await estimateTransactionFeeWithFallback(transaction, network);
        transaction.setFee(fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === TransactionVersion.Mainnet
            ? AddressVersion.MainnetSingleSig
            : AddressVersion.TestnetSingleSig;
        const senderAddress = publicKeyToAddress(addressVersion, pubKey);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
async function estimateContractFunctionCall(transaction, network) {
    if (transaction.payload.payloadType !== PayloadType.ContractCall) {
        throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = intToBigInt(transaction.serialize().byteLength, false);
    const feeRate = intToBigInt(feeRateResult, false);
    return feeRate * txBytes;
}
async function makeUnsignedContractCall(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new StacksMainnet(),
        postConditionMode: PostConditionMode.Deny,
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);
    if (options?.validateWithAbi) {
        let abi;
        if (typeof options.validateWithAbi === 'boolean') {
            if (options?.network) {
                abi = await getAbi(options.contractAddress, options.contractName, options.network);
            }
            else {
                throw new Error('Network option must be provided in order to validate with ABI');
            }
        }
        else {
            abi = options.validateWithAbi;
        }
        validateContractCall(payload, abi);
    }
    let spendingCondition = null;
    let authorization = null;
    if ('publicKey' in options) {
        spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = createSponsoredAuth(spendingCondition);
    }
    else {
        authorization = createStandardAuth(spendingCondition);
    }
    const network = StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = createLPList(postConditions);
    const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const fee = await estimateTransactionFeeWithFallback(transaction, network);
        transaction.setFee(fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = network.version === TransactionVersion.Mainnet
            ? AddressVersion.MainnetSingleSig
            : AddressVersion.TestnetSingleSig;
        const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
async function makeContractCall(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));
        const options = omit(txOptions, 'senderKey');
        const transaction = await makeUnsignedContractCall({ publicKey, ...options });
        const privKey = createStacksPrivateKey(txOptions.senderKey);
        const signer = new TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = omit(txOptions, 'signerKeys');
        const transaction = await makeUnsignedContractCall(options);
        const signer = new TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = pubKeyfromPrivKey(key);
            pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));
            signer.signOrigin(createStacksPrivateKey(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));
        }
        return transaction;
    }
}
function makeStandardSTXPostCondition(address, conditionCode, amount) {
    return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);
}
function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {
    return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);
}
function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {
    return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);
}
function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {
    return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);
}
function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetId) {
    return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetId);
}
function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetId) {
    return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetId);
}
async function callReadOnlyFunction(readOnlyFunctionOptions) {
    const defaultOptions = {
        network: new StacksMainnet(),
    };
    const options = Object.assign(defaultOptions, readOnlyFunctionOptions);
    const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;
    const network = StacksNetwork.fromNameOrNetwork(options.network);
    const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);
    const args = functionArgs.map(arg => cvToHex(arg));
    const body = JSON.stringify({
        sender: senderAddress,
        arguments: args,
    });
    const response = await network.fetchFn(url, {
        method: 'POST',
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    });
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    return response.json().then(responseJson => parseReadOnlyResponse(responseJson));
}
async function getContractMapEntry(getContractMapEntryOptions) {
    const defaultOptions = {
        network: new StacksMainnet(),
    };
    const { contractAddress, contractName, mapName, mapKey, network } = Object.assign(defaultOptions, getContractMapEntryOptions);
    const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);
    const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);
    const serializedKeyBytes = serializeCV(mapKey);
    const serializedKeyHex = '0x' + bytesToHex(serializedKeyBytes);
    const fetchOptions = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            Accept: 'application/json',
        },
        body: JSON.stringify(serializedKeyHex),
    };
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error fetching map entry for map "${mapName}" in contract "${contractName}" at address ${contractAddress}, using map key "${serializedKeyHex}". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const responseBody = await response.text();
    const responseJson = JSON.parse(responseBody);
    if (!responseJson.data) {
        throw new Error(`Error fetching map entry for map "${mapName}" in contract "${contractName}" at address ${contractAddress}, using map key "${serializedKeyHex}". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: "${responseBody}"`);
    }
    let deserializedCv;
    try {
        deserializedCv = deserializeCV(responseJson.data);
    }
    catch (error) {
        throw new Error(`Error deserializing Clarity value "${responseJson.data}": ${error}`);
    }
    return deserializedCv;
}
async function sponsorTransaction(sponsorOptions) {
    const defaultOptions = {
        fee: 0,
        sponsorNonce: 0,
        sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,
        network: sponsorOptions.transaction.version === TransactionVersion.Mainnet
            ? new StacksMainnet()
            : new StacksTestnet(),
    };
    const options = Object.assign(defaultOptions, sponsorOptions);
    const network = StacksNetwork.fromNameOrNetwork(options.network);
    const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);
    if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {
        let txFee = 0;
        switch (options.transaction.payload.payloadType) {
            case PayloadType.TokenTransfer:
            case PayloadType.SmartContract:
            case PayloadType.VersionedSmartContract:
            case PayloadType.ContractCall:
                const estimatedLen = estimateTransactionByteLength(options.transaction);
                try {
                    txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]
                        .fee;
                }
                catch (e) {
                    throw e;
                }
                break;
            default:
                throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);
        }
        options.transaction.setFee(txFee);
        options.fee = txFee;
    }
    if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {
        const addressVersion = network.version === TransactionVersion.Mainnet
            ? AddressVersion.MainnetSingleSig
            : AddressVersion.TestnetSingleSig;
        const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);
        const sponsorNonce = await getNonce(senderAddress, network);
        options.sponsorNonce = sponsorNonce;
    }
    const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);
    options.transaction.setSponsor(sponsorSpendingCondition);
    const privKey = createStacksPrivateKey(options.sponsorPrivateKey);
    const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);
    signer.signSponsor(privKey);
    return signer.transaction;
}
function estimateTransactionByteLength(transaction) {
    const hashMode = transaction.auth.spendingCondition.hashMode;
    const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];
    if (multiSigHashModes.includes(hashMode)) {
        const multiSigSpendingCondition = transaction.auth
            .spendingCondition;
        const existingSignatures = multiSigSpendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length;
        const totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) *
            (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);
        return transaction.serialize().byteLength + totalSignatureLength;
    }
    else {
        return transaction.serialize().byteLength;
    }
}
async function estimateTransactionFeeWithFallback(transaction, network) {
    try {
        const estimatedLen = estimateTransactionByteLength(transaction);
        return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;
    }
    catch (error) {
        if (error instanceof NoEstimateAvailableError) {
            return await estimateTransferUnsafe(transaction, network);
        }
        throw error;
    }
}

const bool = boolCV;
const int = intCV;
const uint = uintCV;
const contractPrincipal = contractPrincipalCV;
const standardPrincipal = standardPrincipalCV;
const list = listCV;
const stringAscii = stringAsciiCV;
const stringUtf8 = stringUtf8CV;
const buffer = bufferCV;
const bufferFromHex = (hex) => bufferCV(hexToBytes(hex));
const bufferFromAscii = (ascii) => bufferCV(asciiToBytes(ascii));
const bufferFromUtf8 = (utf8) => bufferCV(utf8ToBytes(utf8));
const none = noneCV;
const some = someCV;
const ok = responseOkCV;
const error = responseErrorCV;
const tuple = tupleCV;
const serialize = serializeCV;
const deserialize = deserializeCV;

var cl = /*#__PURE__*/Object.freeze({
    __proto__: null,
    bool: bool,
    int: int,
    uint: uint,
    contractPrincipal: contractPrincipal,
    standardPrincipal: standardPrincipal,
    list: list,
    stringAscii: stringAscii,
    stringUtf8: stringUtf8,
    buffer: buffer,
    bufferFromHex: bufferFromHex,
    bufferFromAscii: bufferFromAscii,
    bufferFromUtf8: bufferFromUtf8,
    none: none,
    some: some,
    ok: ok,
    error: error,
    tuple: tuple,
    serialize: serialize,
    deserialize: deserialize
});

function principal(principal) {
    if (isContractIdString(principal)) {
        const [address, name] = parseContractId(principal);
        return new PartialPcWithPrincipal(address, name);
    }
    return new PartialPcWithPrincipal(principal, undefined);
}
class PartialPcWithPrincipal {
    constructor(address, contractName) {
        this.address = address;
        this.contractName = contractName;
    }
    willSendEq(amount) {
        return new PartialPcFtWithCode(this.address, amount, FungibleConditionCode.Equal, this.contractName);
    }
    willSendLte(amount) {
        return new PartialPcFtWithCode(this.address, amount, FungibleConditionCode.LessEqual, this.contractName);
    }
    willSendLt(amount) {
        return new PartialPcFtWithCode(this.address, amount, FungibleConditionCode.Less, this.contractName);
    }
    willSendGte(amount) {
        return new PartialPcFtWithCode(this.address, amount, FungibleConditionCode.GreaterEqual, this.contractName);
    }
    willSendGt(amount) {
        return new PartialPcFtWithCode(this.address, amount, FungibleConditionCode.Greater, this.contractName);
    }
    willSendAsset() {
        return new PartialPcNftWithCode(this.address, NonFungibleConditionCode.Sends, this.contractName);
    }
    willNotSendAsset() {
        return new PartialPcNftWithCode(this.address, NonFungibleConditionCode.DoesNotSend, this.contractName);
    }
}
class PartialPcFtWithCode {
    constructor(address, amount, code, contractName) {
        this.address = address;
        this.amount = amount;
        this.code = code;
        this.contractName = contractName;
    }
    ustx() {
        if (this.contractName) {
            return makeContractSTXPostCondition(this.address, this.contractName, this.code, this.amount);
        }
        return makeStandardSTXPostCondition(this.address, this.code, this.amount);
    }
    ft(contractId, tokenName) {
        const [address, name] = parseContractId(contractId);
        if (this.contractName) {
            return makeContractFungiblePostCondition(this.address, this.contractName, this.code, this.amount, createAssetInfo(address, name, tokenName));
        }
        return makeStandardFungiblePostCondition(this.address, this.code, this.amount, createAssetInfo(address, name, tokenName));
    }
}
class PartialPcNftWithCode {
    constructor(principal, code, contractName) {
        this.principal = principal;
        this.code = code;
        this.contractName = contractName;
    }
    nft(...args) {
        const { contractAddress, contractName, tokenName, assetId } = getNftArgs(...args);
        if (this.contractName) {
            return makeContractNonFungiblePostCondition(this.principal, this.contractName, this.code, createAssetInfo(contractAddress, contractName, tokenName), assetId);
        }
        return makeStandardNonFungiblePostCondition(this.principal, this.code, createAssetInfo(contractAddress, contractName, tokenName), assetId);
    }
}
function parseContractId(contractId) {
    const [address, name] = contractId.split('.');
    if (!address || !name)
        throw new Error(`Invalid contract identifier: ${contractId}`);
    return [address, name];
}
function parseNft(nftAssetName) {
    const [principal, tokenName] = nftAssetName.split('::');
    if (!principal || !tokenName)
        throw new Error(`Invalid fully-qualified nft asset name: ${nftAssetName}`);
    const [address, name] = parseContractId(principal);
    return { contractAddress: address, contractName: name, tokenName };
}
function isContractIdString(value) {
    return value.includes('.');
}
function getNftArgs(...args) {
    if (args.length === 2) {
        const [assetName, assetId] = args;
        return { ...parseNft(assetName), assetId };
    }
    const [contractId, tokenName, assetId] = args;
    const [address, name] = parseContractId(contractId);
    return { contractAddress: address, contractName: name, tokenName, assetId };
}

var pc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    principal: principal
});

const STRUCTURED_DATA_PREFIX = new Uint8Array([0x53, 0x49, 0x50, 0x30, 0x31, 0x38]);
function hashStructuredData(structuredData) {
    return sha256(serializeCV(structuredData));
}
const hash256BytesLength = 32;
function isDomain(value) {
    if (value.type !== ClarityType.Tuple)
        return false;
    if (!['name', 'version', 'chain-id'].every(key => key in value.data))
        return false;
    if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII))
        return false;
    if (value.data['chain-id'].type !== ClarityType.UInt)
        return false;
    return true;
}
function encodeStructuredData({ message, domain, }) {
    const structuredDataHash = hashStructuredData(message);
    if (!isDomain(domain)) {
        throw new Error("domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt");
    }
    const domainHash = hashStructuredData(domain);
    return concatBytes(STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);
}
function decodeStructuredDataSignature(signature) {
    const encodedMessageBytes = typeof signature === 'string' ? utf8ToBytes(signature) : signature;
    const domainHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length, STRUCTURED_DATA_PREFIX.length + hash256BytesLength);
    const messageHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);
    return {
        domainHash,
        messageHash,
    };
}
function signStructuredData({ message, domain, privateKey, }) {
    const structuredDataHash = bytesToHex(sha256(encodeStructuredData({ message, domain })));
    const { data } = signMessageHashRsv({
        messageHash: structuredDataHash,
        privateKey,
    });
    return {
        data,
        type: StacksMessageType.StructuredDataSignature,
    };
}

export { AddressHashMode, AddressVersion, AnchorMode, AnchorModeNames, AssetType, AuthFieldType, AuthType, BytesReader, CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE, COINBASE_LENGTH_BYTES as COINBASE_BYTES_LENGTH, COMPRESSED_PUBKEY_LENGTH_BYTES, ChainID, cl as Cl, ClarityAbiTypeId, ClarityType, ClarityVersion, DEFAULT_CHAIN_ID, DEFAULT_CORE_NODE_API_URL, DEFAULT_TRANSACTION_VERSION, FungibleConditionCode, MAX_STRING_LENGTH_BYTES, MEMO_MAX_LENGTH_BYTES, NonFungibleConditionCode, PayloadType, pc as Pc, PostConditionMode, PostConditionPrincipalID, PostConditionType, PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, STRUCTURED_DATA_PREFIX, StacksMessageType, StacksTransaction, TransactionSigner, TransactionVersion, TxRejectedReason, UNCOMPRESSED_PUBKEY_LENGTH_BYTES, abiFunctionToString, addressFromHashMode, addressFromPublicKeys, addressFromVersionHash, addressHashModeToVersion, addressToString, anchorModeFromNameOrValue, boolCV, broadcastRawTransaction, broadcastTransaction, bufferCV, bufferCVFromString, callReadOnlyFunction, cloneDeep, codeBodyString, compressPublicKey, contractPrincipalCV, contractPrincipalCVFromAddress, contractPrincipalCVFromStandard, createAddress, createAssetInfo, createContractPrincipal, createEmptyAddress, createFungiblePostCondition, createLPList, createLPString, createMemoString, createMessageSignature, createMultiSigSpendingCondition, createNonFungiblePostCondition, createSTXPostCondition, createSingleSigSpendingCondition, createSponsoredAuth, createStacksPrivateKey, createStacksPublicKey, createStandardAuth, createStandardPrincipal, createTransactionAuthField, cvToHex, cvToJSON, cvToString, cvToValue, decodeStructuredDataSignature, deserializeAddress, deserializeAssetInfo, deserializeAuthorization, deserializeCV, deserializeLPList, deserializeLPString, deserializeMemoString, deserializeMessageSignature, deserializeMultiSigSpendingCondition, deserializePostCondition, deserializePrincipal, deserializePublicKey, deserializeSingleSigSpendingCondition, deserializeSpendingCondition, deserializeStacksMessage, deserializeTransaction, deserializeTransactionAuthField, emptyMessageSignature, encodeClarityValue, encodeStructuredData, estimateContractDeploy, estimateContractFunctionCall, estimateTransaction, estimateTransactionByteLength, estimateTransactionFeeWithFallback, estimateTransfer, estimateTransferUnsafe, exceedsMaxLengthBytes, falseCV, getAbi, getAddressFromPrivateKey, getAddressFromPublicKey, getCVTypeString, getContractMapEntry, getFee, getNonce, getPublicKey, getTypeString, getTypeUnion, hash160, hashP2PKH, hashP2SH, hashP2WPKH, hashP2WSH, hashStructuredData, hexToCV, intCV, intoInitialSighashAuth, isClarityAbiBuffer, isClarityAbiList, isClarityAbiOptional, isClarityAbiPrimitive, isClarityAbiResponse, isClarityAbiStringAscii, isClarityAbiStringUtf8, isClarityAbiTuple, isClarityName, isCoinbasePayload, isCompressed, isContractCallPayload, isPoisonPayload, isSingleSig, isSmartContractPayload, isTokenTransferPayload, leftPadHex, leftPadHexToLength, listCV, makeContractCall, makeContractDeploy, makeContractFungiblePostCondition, makeContractNonFungiblePostCondition, makeContractSTXPostCondition, makeRandomPrivKey, makeSTXTokenTransfer, makeSigHashPreSign, makeStandardFungiblePostCondition, makeStandardNonFungiblePostCondition, makeStandardSTXPostCondition, makeUnsignedContractCall, makeUnsignedContractDeploy, makeUnsignedSTXTokenTransfer, nextSignature, nextVerification, noneCV, omit, optionalCVOf, parseAssetInfoString, parsePrincipalString, parseReadOnlyResponse, parseToCV, principalCV, principalToString, privateKeyToString, pubKeyfromPrivKey, publicKeyFromBytes, publicKeyFromSignatureRsv, publicKeyFromSignatureVrs, publicKeyToAddress, publicKeyToString, randomBytes, responseErrorCV, responseOkCV, rightPadHexToLength, serializeAddress, serializeAssetInfo, serializeAuthorization, serializeCV, serializeLPList, serializeLPString, serializeMemoString, serializeMessageSignature, serializeMultiSigSpendingCondition, serializePayload, serializePostCondition, serializePrincipal, serializePublicKey, serializeSingleSigSpendingCondition, serializeSpendingCondition, serializeStacksMessage, serializeTransactionAuthField, setFee, setNonce, setSponsor, setSponsorNonce, signMessageHashRsv, signStructuredData, signWithKey, someCV, sponsorTransaction, standardPrincipalCV, standardPrincipalCVFromAddress, stringAsciiCV, stringCV, stringUtf8CV, trueCV, tupleCV, txidFromData, uintCV, validateContractCall, validateStacksAddress, validateTxId, verifyOrigin, whenMessageType };
