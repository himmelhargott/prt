const config = {
    network: {
        layer1: 'placeholder',
    },
    logLevel: 'debug',
};

const ERROR_CODES = {
    MISSING_PARAMETER: 'missing_parameter',
    REMOTE_SERVICE_ERROR: 'remote_service_error',
    INVALID_STATE: 'invalid_state',
    NO_SESSION_DATA: 'no_session_data',
    DOES_NOT_EXIST: 'does_not_exist',
    FAILED_DECRYPTION_ERROR: 'failed_decryption_error',
    INVALID_DID_ERROR: 'invalid_did_error',
    NOT_ENOUGH_FUNDS_ERROR: 'not_enough_error',
    INVALID_AMOUNT_ERROR: 'invalid_amount_error',
    LOGIN_FAILED_ERROR: 'login_failed',
    SIGNATURE_VERIFICATION_ERROR: 'signature_verification_failure',
    CONFLICT_ERROR: 'conflict_error',
    NOT_ENOUGH_PROOF_ERROR: 'not_enough_proof_error',
    BAD_PATH_ERROR: 'bad_path_error',
    VALIDATION_ERROR: 'validation_error',
    PAYLOAD_TOO_LARGE_ERROR: 'payload_too_large_error',
    PRECONDITION_FAILED_ERROR: 'precondition_failed_error',
    UNKNOWN: 'unknown',
};
Object.freeze(ERROR_CODES);
class BlockstackError extends Error {
    constructor(error) {
        super();
        let message = error.message;
        let bugDetails = `Error Code: ${error.code}`;
        let stack = this.stack;
        if (!stack) {
            try {
                throw new Error();
            }
            catch (e) {
                stack = e.stack;
            }
        }
        else {
            bugDetails += `Stack Trace:\n${stack}`;
        }
        message += `\nIf you believe this exception is caused by a bug in stacks.js,
      please file a bug report: https://github.com/blockstack/stacks.js/issues\n\n${bugDetails}`;
        this.message = message;
        this.code = error.code;
        this.parameter = error.parameter ? error.parameter : undefined;
    }
    toString() {
        return `${super.toString()}
    code: ${this.code} param: ${this.parameter ? this.parameter : 'n/a'}`;
    }
}
class InvalidParameterError extends BlockstackError {
    constructor(parameter, message = '') {
        super({ code: ERROR_CODES.MISSING_PARAMETER, message, parameter });
        this.name = 'MissingParametersError';
    }
}
class MissingParameterError extends BlockstackError {
    constructor(parameter, message = '') {
        super({ code: ERROR_CODES.MISSING_PARAMETER, message, parameter });
        this.name = 'MissingParametersError';
    }
}
class RemoteServiceError extends BlockstackError {
    constructor(response, message = '') {
        super({ code: ERROR_CODES.REMOTE_SERVICE_ERROR, message });
        this.response = response;
    }
}
class InvalidDIDError extends BlockstackError {
    constructor(message = '') {
        super({ code: ERROR_CODES.INVALID_DID_ERROR, message });
        this.name = 'InvalidDIDError';
    }
}
class NotEnoughFundsError extends BlockstackError {
    constructor(leftToFund) {
        const message = `Not enough UTXOs to fund. Left to fund: ${leftToFund}`;
        super({ code: ERROR_CODES.NOT_ENOUGH_FUNDS_ERROR, message });
        this.leftToFund = leftToFund;
        this.name = 'NotEnoughFundsError';
        this.message = message;
    }
}
class InvalidAmountError extends BlockstackError {
    constructor(fees, specifiedAmount) {
        const message = `Not enough coin to fund fees transaction fees. Fees would be ${fees},` +
            ` specified spend is  ${specifiedAmount}`;
        super({ code: ERROR_CODES.INVALID_AMOUNT_ERROR, message });
        this.specifiedAmount = specifiedAmount;
        this.fees = fees;
        this.name = 'InvalidAmountError';
        this.message = message;
    }
}
class LoginFailedError extends BlockstackError {
    constructor(reason) {
        const message = `Failed to login: ${reason}`;
        super({ code: ERROR_CODES.LOGIN_FAILED_ERROR, message });
        this.message = message;
        this.name = 'LoginFailedError';
    }
}
class SignatureVerificationError extends BlockstackError {
    constructor(reason) {
        const message = `Failed to verify signature: ${reason}`;
        super({ code: ERROR_CODES.SIGNATURE_VERIFICATION_ERROR, message });
        this.message = message;
        this.name = 'SignatureVerificationError';
    }
}
class FailedDecryptionError extends BlockstackError {
    constructor(message = 'Unable to decrypt cipher object.') {
        super({ code: ERROR_CODES.FAILED_DECRYPTION_ERROR, message });
        this.message = message;
        this.name = 'FailedDecryptionError';
    }
}
class InvalidStateError extends BlockstackError {
    constructor(message) {
        super({ code: ERROR_CODES.INVALID_STATE, message });
        this.message = message;
        this.name = 'InvalidStateError';
    }
}
class NoSessionDataError extends BlockstackError {
    constructor(message) {
        super({ code: ERROR_CODES.INVALID_STATE, message });
        this.message = message;
        this.name = 'NoSessionDataError';
    }
}
class GaiaHubError extends BlockstackError {
    constructor(error, response) {
        super(error);
        if (response) {
            this.hubError = {
                statusCode: response.status,
                statusText: response.statusText,
            };
            if (typeof response.body === 'string') {
                this.hubError.message = response.body;
            }
            else if (typeof response.body === 'object') {
                Object.assign(this.hubError, response.body);
            }
        }
    }
}
class DoesNotExist extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: ERROR_CODES.DOES_NOT_EXIST }, response);
        this.name = 'DoesNotExist';
    }
}
class ConflictError extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: ERROR_CODES.CONFLICT_ERROR }, response);
        this.name = 'ConflictError';
    }
}
class NotEnoughProofError extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: ERROR_CODES.NOT_ENOUGH_PROOF_ERROR }, response);
        this.name = 'NotEnoughProofError';
    }
}
class BadPathError extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: ERROR_CODES.BAD_PATH_ERROR }, response);
        this.name = 'BadPathError';
    }
}
class ValidationError extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: ERROR_CODES.VALIDATION_ERROR }, response);
        this.name = 'ValidationError';
    }
}
class PayloadTooLargeError extends GaiaHubError {
    constructor(message, response, maxUploadByteSize) {
        super({ message, code: ERROR_CODES.PAYLOAD_TOO_LARGE_ERROR }, response);
        this.name = 'PayloadTooLargeError';
        this.maxUploadByteSize = maxUploadByteSize;
    }
}
class PreconditionFailedError extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: ERROR_CODES.PRECONDITION_FAILED_ERROR }, response);
        this.name = 'PreconditionFailedError';
    }
}

const levels = ['debug', 'info', 'warn', 'error', 'none'];
const levelToInt = {};
for (let index = 0; index < levels.length; index++) {
    const level = levels[index];
    levelToInt[level] = index;
}
class Logger {
    static error(message) {
        if (!this.shouldLog('error'))
            return;
        console.error(this.logMessage('error', message));
    }
    static warn(message) {
        if (!this.shouldLog('warn'))
            return;
        console.warn(this.logMessage('warn', message));
    }
    static info(message) {
        if (!this.shouldLog('info'))
            return;
        console.log(this.logMessage('info', message));
    }
    static debug(message) {
        if (!this.shouldLog('debug'))
            return;
        console.log(this.logMessage('debug', message));
    }
    static logMessage(level, message) {
        return `[${level.toUpperCase()}] ${message}`;
    }
    static shouldLog(level) {
        const currentLevel = levelToInt[config.logLevel];
        return currentLevel <= levelToInt[level];
    }
}

const BLOCKSTACK_HANDLER = 'blockstack';
function nextYear() {
    return new Date(new Date().setFullYear(new Date().getFullYear() + 1));
}
function nextMonth() {
    return new Date(new Date().setMonth(new Date().getMonth() + 1));
}
function nextHour() {
    return new Date(new Date().setHours(new Date().getHours() + 1));
}
function megabytesToBytes(megabytes) {
    if (!Number.isFinite(megabytes)) {
        return 0;
    }
    return Math.floor(megabytes * 1024 * 1024);
}
function getAesCbcOutputLength(inputByteLength) {
    const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;
    return cipherTextLength;
}
function getBase64OutputLength(inputByteLength) {
    const encodedLength = Math.ceil(inputByteLength / 3) * 4;
    return encodedLength;
}
function updateQueryStringParameter(uri, key, value) {
    const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');
    const separator = uri.indexOf('?') !== -1 ? '&' : '?';
    if (uri.match(re)) {
        return uri.replace(re, `$1${key}=${value}$2`);
    }
    else {
        return `${uri}${separator}${key}=${value}`;
    }
}
function isLaterVersion(v1, v2) {
    if (v1 === undefined || v1 === '') {
        v1 = '0.0.0';
    }
    if (v2 === undefined || v1 === '') {
        v2 = '0.0.0';
    }
    const v1tuple = v1.split('.').map(x => parseInt(x, 10));
    const v2tuple = v2.split('.').map(x => parseInt(x, 10));
    for (let index = 0; index < v2.length; index++) {
        if (index >= v1.length) {
            v2tuple.push(0);
        }
        if (v1tuple[index] < v2tuple[index]) {
            return false;
        }
    }
    return true;
}
function makeUUID4() {
    let d = new Date().getTime();
    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
        d += performance.now();
    }
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
}
function isSameOriginAbsoluteUrl(uri1, uri2) {
    try {
        const parsedUri1 = new URL(uri1);
        const parsedUri2 = new URL(uri2);
        const port1 = parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);
        const port2 = parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);
        const match = {
            scheme: parsedUri1.protocol === parsedUri2.protocol,
            hostname: parsedUri1.hostname === parsedUri2.hostname,
            port: port1 === port2,
            absolute: (uri1.includes('http://') || uri1.includes('https://')) &&
                (uri2.includes('http://') || uri2.includes('https://')),
        };
        return match.scheme && match.hostname && match.port && match.absolute;
    }
    catch (error) {
        console.log(error);
        console.log('Parsing error in same URL origin check');
        return false;
    }
}
function getGlobalScope() {
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available');
}
function getAPIUsageErrorMessage(scopeObject, apiName, usageDesc) {
    if (usageDesc) {
        return `Use of '${usageDesc}' requires \`${apiName}\` which is unavailable on the '${scopeObject}' object within the currently executing environment.`;
    }
    else {
        return `\`${apiName}\` is unavailable on the '${scopeObject}' object within the currently executing environment.`;
    }
}
function getGlobalObject(name, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {
    let globalScope = undefined;
    try {
        globalScope = getGlobalScope();
        if (globalScope) {
            const obj = globalScope[name];
            if (obj) {
                return obj;
            }
        }
    }
    catch (error) {
        Logger.error(`Error getting object '${name}' from global scope '${globalScope}': ${error}`);
    }
    if (throwIfUnavailable) {
        const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);
        Logger.error(errMsg);
        throw new Error(errMsg);
    }
    if (returnEmptyObject) {
        return {};
    }
    return undefined;
}
function getGlobalObjects(names, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {
    let globalScope;
    try {
        globalScope = getGlobalScope();
    }
    catch (error) {
        Logger.error(`Error getting global scope: ${error}`);
        if (throwIfUnavailable) {
            const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);
            Logger.error(errMsg);
            throw errMsg;
        }
        else if (returnEmptyObject) {
            globalScope = {};
        }
    }
    const result = {};
    for (let i = 0; i < names.length; i++) {
        const name = names[i];
        try {
            if (globalScope) {
                const obj = globalScope[name];
                if (obj) {
                    result[name] = obj;
                }
                else if (throwIfUnavailable) {
                    const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);
                    Logger.error(errMsg);
                    throw new Error(errMsg);
                }
                else if (returnEmptyObject) {
                    result[name] = {};
                }
            }
        }
        catch (error) {
            if (throwIfUnavailable) {
                const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);
                Logger.error(errMsg);
                throw new Error(errMsg);
            }
        }
    }
    return result;
}
function intToBytes(value, signed, byteLength) {
    return bigIntToBytes(intToBigInt(value, signed), byteLength);
}
function intToBigInt(value, signed) {
    let parsedValue = value;
    if (typeof parsedValue === 'number') {
        if (!Number.isInteger(parsedValue)) {
            throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);
        }
        return BigInt(parsedValue);
    }
    if (typeof parsedValue === 'string') {
        if (parsedValue.toLowerCase().startsWith('0x')) {
            let hex = parsedValue.slice(2);
            hex = hex.padStart(hex.length + (hex.length % 2), '0');
            parsedValue = hexToBytes(hex);
        }
        else {
            try {
                return BigInt(parsedValue);
            }
            catch (error) {
                if (error instanceof SyntaxError) {
                    throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);
                }
            }
        }
    }
    if (typeof parsedValue === 'bigint') {
        return parsedValue;
    }
    if (parsedValue instanceof Uint8Array) {
        if (signed) {
            const bn = fromTwos(BigInt(`0x${bytesToHex(parsedValue)}`), BigInt(parsedValue.byteLength * 8));
            return BigInt(bn.toString());
        }
        else {
            return BigInt(`0x${bytesToHex(parsedValue)}`);
        }
    }
    if (parsedValue != null &&
        typeof parsedValue === 'object' &&
        parsedValue.constructor.name === 'BN') {
        return BigInt(parsedValue.toString());
    }
    throw new TypeError(`Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.`);
}
function with0x(value) {
    return value.startsWith('0x') ? value : `0x${value}`;
}
function hexToBigInt(hex) {
    if (typeof hex !== 'string')
        throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);
    return BigInt(`0x${hex}`);
}
function intToHex(integer, lengthBytes = 8) {
    const value = typeof integer === 'bigint' ? integer : intToBigInt(integer, false);
    return value.toString(16).padStart(lengthBytes * 2, '0');
}
function hexToInt(hex) {
    return parseInt(hex, 16);
}
function bigIntToBytes(value, length = 16) {
    const hex = intToHex(value, length);
    return hexToBytes(hex);
}
function toTwos(value, width) {
    if (value < -(BigInt(1) << (width - BigInt(1))) ||
        (BigInt(1) << (width - BigInt(1))) - BigInt(1) < value) {
        throw `Unable to represent integer in width: ${width}`;
    }
    if (value >= BigInt(0)) {
        return BigInt(value);
    }
    return value + (BigInt(1) << width);
}
function nthBit(value, n) {
    return value & (BigInt(1) << n);
}
function fromTwos(value, width) {
    if (nthBit(value, width - BigInt(1))) {
        return value - (BigInt(1) << width);
    }
    return value;
}
const hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (const u of uint8a) {
        hex += hexes[u];
    }
    return hex;
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);
    }
    const paddedHex = hex.length % 2 ? `0${hex}` : hex;
    const array = new Uint8Array(paddedHex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = paddedHex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
function utf8ToBytes(str) {
    return new TextEncoder().encode(str);
}
function bytesToUtf8(arr) {
    return new TextDecoder().decode(arr);
}
function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; i++) {
        byteArray.push(str.charCodeAt(i) & 0xff);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(arr) {
    return String.fromCharCode.apply(null, arr);
}
function isNotOctet(octet) {
    return !Number.isInteger(octet) || octet < 0 || octet > 255;
}
function octetsToBytes(numbers) {
    if (numbers.some(isNotOctet))
        throw new Error('Some values are invalid bytes.');
    return new Uint8Array(numbers);
}
function toBytes(data) {
    if (typeof data === 'string')
        return utf8ToBytes(data);
    if (data instanceof Uint8Array)
        return data;
    throw new TypeError(`Expected input type is (Uint8Array | string) but got (${typeof data})`);
}
function concatBytes(...arrays) {
    if (!arrays.every(a => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function concatArray(elements) {
    return concatBytes(...elements.map(e => {
        if (typeof e === 'number')
            return octetsToBytes([e]);
        if (e instanceof Array)
            return octetsToBytes(e);
        return e;
    }));
}
function isInstance(object, type) {
    return object instanceof type || object?.constructor?.name?.toLowerCase() === type.name;
}

var ChainID;
(function (ChainID) {
    ChainID[ChainID["Testnet"] = 2147483648] = "Testnet";
    ChainID[ChainID["Mainnet"] = 1] = "Mainnet";
})(ChainID || (ChainID = {}));
var TransactionVersion;
(function (TransactionVersion) {
    TransactionVersion[TransactionVersion["Mainnet"] = 0] = "Mainnet";
    TransactionVersion[TransactionVersion["Testnet"] = 128] = "Testnet";
})(TransactionVersion || (TransactionVersion = {}));
const PRIVATE_KEY_COMPRESSED_LENGTH = 33;
const PRIVATE_KEY_UNCOMPRESSED_LENGTH = 32;
const BLOCKSTACK_DEFAULT_GAIA_HUB_URL = 'https://hub.blockstack.org';

const COORDINATE_BYTES = 32;
function parseRecoverableSignatureVrs(signature) {
    if (signature.length < COORDINATE_BYTES * 2 * 2 + 1) {
        throw new Error('Invalid signature');
    }
    const recoveryIdHex = signature.slice(0, 2);
    const r = signature.slice(2, 2 + COORDINATE_BYTES * 2);
    const s = signature.slice(2 + COORDINATE_BYTES * 2);
    return {
        recoveryId: hexToInt(recoveryIdHex),
        r,
        s,
    };
}
function signatureVrsToRsv(signature) {
    return signature.slice(2) + signature.slice(0, 2);
}
function signatureRsvToVrs(signature) {
    return signature.slice(-2) + signature.slice(0, -2);
}

function privateKeyToBytes(privateKey) {
    const privateKeyBuffer = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;
    if (privateKeyBuffer.length != 32 && privateKeyBuffer.length != 33) {
        throw new Error(`Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${privateKeyBuffer.length}`);
    }
    if (privateKeyBuffer.length == 33 && privateKeyBuffer[32] !== 1) {
        throw new Error('Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01');
    }
    return privateKeyBuffer;
}

function equals(a, b) {
    if (a.byteLength !== b.byteLength)
        return false;
    for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
}
function alloc(length, value) {
    const a = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
        a[i] = value;
    }
    return a;
}
function readUInt16BE(source, offset) {
    return ((source[offset + 0] << 8) | source[offset + 1]) >>> 0;
}
function writeUInt16BE(source, value, offset) {
    source[offset + 0] = value >>> 8;
    source[offset + 1] = value >>> 0;
}
function readUInt8(source, offset) {
    return source[offset];
}
function writeUInt8(destination, value, offset) {
    destination[offset] = value;
}
function readUInt16LE(source, offset) {
    return ((source[offset + 0] << 0) >>> 0) | ((source[offset + 1] << 8) >>> 0);
}
function writeUInt16LE(destination, value, offset) {
    destination[offset + 0] = value & 255;
    value >>>= 8;
    destination[offset + 1] = value & 255;
}
function readUInt32BE(source, offset) {
    return (source[offset] * 2 ** 24 +
        source[offset + 1] * 2 ** 16 +
        source[offset + 2] * 2 ** 8 +
        source[offset + 3]);
}
function writeUInt32BE(destination, value, offset) {
    destination[offset + 3] = value;
    value >>>= 8;
    destination[offset + 2] = value;
    value >>>= 8;
    destination[offset + 1] = value;
    value >>>= 8;
    destination[offset] = value;
}
function readUInt32LE(source, offset) {
    return (((source[offset + 0] << 0) >>> 0) |
        ((source[offset + 1] << 8) >>> 0) |
        ((source[offset + 2] << 16) >>> 0) |
        ((source[offset + 3] << 24) >>> 0));
}
function writeUInt32LE(destination, value, offset) {
    destination[offset + 0] = value & 255;
    value >>>= 8;
    destination[offset + 1] = value & 255;
    value >>>= 8;
    destination[offset + 2] = value & 255;
    value >>>= 8;
    destination[offset + 3] = value & 255;
}

export { BLOCKSTACK_DEFAULT_GAIA_HUB_URL, BLOCKSTACK_HANDLER, BadPathError, BlockstackError, ChainID, ConflictError, DoesNotExist, ERROR_CODES, FailedDecryptionError, GaiaHubError, InvalidAmountError, InvalidDIDError, InvalidParameterError, InvalidStateError, Logger, LoginFailedError, MissingParameterError, NoSessionDataError, NotEnoughFundsError, NotEnoughProofError, PRIVATE_KEY_COMPRESSED_LENGTH, PRIVATE_KEY_UNCOMPRESSED_LENGTH, PayloadTooLargeError, PreconditionFailedError, RemoteServiceError, SignatureVerificationError, TransactionVersion, ValidationError, alloc, asciiToBytes, bigIntToBytes, bytesToAscii, bytesToHex, bytesToUtf8, concatArray, concatBytes, config, equals, fromTwos, getAesCbcOutputLength, getBase64OutputLength, getGlobalObject, getGlobalObjects, getGlobalScope, hexToBigInt, hexToBytes, hexToInt, intToBigInt, intToBytes, intToHex, isInstance, isLaterVersion, isSameOriginAbsoluteUrl, makeUUID4, megabytesToBytes, nextHour, nextMonth, nextYear, octetsToBytes, parseRecoverableSignatureVrs, privateKeyToBytes, readUInt16BE, readUInt16LE, readUInt32BE, readUInt32LE, readUInt8, signatureRsvToVrs, signatureVrsToRsv, toBytes, toTwos, updateQueryStringParameter, utf8ToBytes, with0x, writeUInt16BE, writeUInt16LE, writeUInt32BE, writeUInt32LE, writeUInt8 };
