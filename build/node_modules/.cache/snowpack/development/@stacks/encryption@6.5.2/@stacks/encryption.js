import { hmac } from '../../../../../../../_snowpack/pkg/@noble/hashes/hmac.js';
import { sha256 } from '../../../../../../../_snowpack/pkg/@noble/hashes/sha256.js';
import { utils, getPublicKey, signSync, getSharedSecret, verify, Signature, Point } from '../../../../../../../_snowpack/pkg/@noble/secp256k1.js';
export { Signature, verify as verifySignature } from '../../../../../../../_snowpack/pkg/@noble/secp256k1.js';
import { concatBytes, bytesToHex, readUInt8, hexToBytes, privateKeyToBytes, PRIVATE_KEY_COMPRESSED_LENGTH, writeUInt8, writeUInt16LE, writeUInt32LE, readUInt16LE, readUInt32LE, utf8ToBytes, bigIntToBytes, FailedDecryptionError, bytesToUtf8, parseRecoverableSignatureVrs, hexToBigInt, signatureRsvToVrs, writeUInt32BE, equals } from '../../../../../../../_snowpack/pkg/@stacks/common.js';
import { fromByteArray, toByteArray } from '../../../../../../../_snowpack/pkg/base64-js.js';
import base58 from '../../../../../../../_snowpack/pkg/bs58.js';
import { ripemd160 } from '../../../../../../../_snowpack/pkg/@noble/hashes/ripemd160.js';
import { sha512 } from '../../../../../../../_snowpack/pkg/@noble/hashes/sha512.js';
import { mnemonicToEntropy, entropyToMnemonic, validateMnemonic } from '../../../../../../../_snowpack/pkg/@scure/bip39.js';
import { wordlist } from '../../../../../../../_snowpack/pkg/@scure/bip39/wordlists/english.js';

function isSubtleCryptoAvailable() {
    return typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined';
}
const NO_CRYPTO_LIB = 'Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';
async function getCryptoLib() {
    if (isSubtleCryptoAvailable()) {
        return {
            lib: crypto.subtle,
            name: 'subtleCrypto',
        };
    }
    else {
        try {
            const nodeCrypto = require('crypto');
            return {
                lib: nodeCrypto,
                name: 'nodeCrypto',
            };
        }
        catch (error) {
            throw new Error(NO_CRYPTO_LIB);
        }
    }
}

class NodeCryptoAesCipher {
    constructor(createCipher, createDecipher) {
        this.createCipher = createCipher;
        this.createDecipher = createDecipher;
    }
    async encrypt(algorithm, key, iv, data) {
        if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {
            throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
        }
        const cipher = this.createCipher(algorithm, key, iv);
        const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));
        return Promise.resolve(result);
    }
    async decrypt(algorithm, key, iv, data) {
        if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {
            throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
        }
        const cipher = this.createDecipher(algorithm, key, iv);
        const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));
        return Promise.resolve(result);
    }
}
class WebCryptoAesCipher {
    constructor(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    async encrypt(algorithm, key, iv, data) {
        let algo;
        let length;
        if (algorithm === 'aes-128-cbc') {
            algo = 'AES-CBC';
            length = 128;
        }
        else if (algorithm === 'aes-256-cbc') {
            algo = 'AES-CBC';
            length = 256;
        }
        else {
            throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
        }
        const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [
            'encrypt',
        ]);
        const result = await this.subtleCrypto.encrypt({ name: algo, iv }, cryptoKey, data);
        return new Uint8Array(result);
    }
    async decrypt(algorithm, key, iv, data) {
        let algo;
        let length;
        if (algorithm === 'aes-128-cbc') {
            algo = 'AES-CBC';
            length = 128;
        }
        else if (algorithm === 'aes-256-cbc') {
            algo = 'AES-CBC';
            length = 256;
        }
        else {
            throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
        }
        const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [
            'decrypt',
        ]);
        const result = await this.subtleCrypto.decrypt({ name: algo, iv }, cryptoKey, data);
        return new Uint8Array(result);
    }
}
async function createCipher() {
    const cryptoLib = await getCryptoLib();
    if (cryptoLib.name === 'subtleCrypto') {
        return new WebCryptoAesCipher(cryptoLib.lib);
    }
    return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);
}

function hashRipemd160(data) {
    return ripemd160(data);
}

class NodeCryptoSha2Hash {
    constructor(createHash) {
        this.createHash = createHash;
    }
    async digest(data, algorithm = 'sha256') {
        try {
            const result = this.createHash(algorithm).update(data).digest();
            return Promise.resolve(result);
        }
        catch (error) {
            console.log(error);
            console.log(`Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`);
            return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));
        }
    }
}
class WebCryptoSha2Hash {
    constructor(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    async digest(data, algorithm = 'sha256') {
        let algo;
        if (algorithm === 'sha256') {
            algo = 'SHA-256';
        }
        else if (algorithm === 'sha512') {
            algo = 'SHA-512';
        }
        else {
            throw new Error(`Unsupported hash algorithm ${algorithm}`);
        }
        try {
            const hash = await this.subtleCrypto.digest(algo, data);
            return new Uint8Array(hash);
        }
        catch (error) {
            console.log(error);
            console.log(`Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`);
            return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));
        }
    }
}
async function createSha2Hash() {
    const cryptoLib = await getCryptoLib();
    if (cryptoLib.name === 'subtleCrypto') {
        return new WebCryptoSha2Hash(cryptoLib.lib);
    }
    else {
        return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);
    }
}
function hashSha256Sync(data) {
    return sha256(data);
}
function hashSha512Sync(data) {
    return sha512(data);
}

const BITCOIN_PUBKEYHASH = 0x00;
utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac.create(sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
function makeECPrivateKey() {
    return bytesToHex(utils.randomPrivateKey());
}
function base58CheckDecode(btcAddress) {
    const bytes = base58.decode(btcAddress);
    const payload = bytes.slice(0, -4);
    const checksum = bytes.slice(-4);
    const newChecksum = sha256(sha256(payload));
    if ((checksum[0] ^ newChecksum[0]) |
        (checksum[1] ^ newChecksum[1]) |
        (checksum[2] ^ newChecksum[2]) |
        (checksum[3] ^ newChecksum[3])) {
        throw new Error('Invalid checksum');
    }
    if (payload.length !== 21)
        throw new TypeError('Invalid address length');
    const version = readUInt8(payload, 0);
    const hash = payload.slice(1);
    return { version, hash };
}
function base58Encode(hash) {
    const checksum = sha256(sha256(hash));
    return base58.encode(concatBytes(hash, checksum).slice(0, hash.length + 4));
}
function base58CheckEncode(version, hash) {
    return base58Encode(concatBytes(new Uint8Array([version]), hash.slice(0, 20)));
}
function publicKeyToBtcAddress(publicKey, version = BITCOIN_PUBKEYHASH) {
    const publicKeyBytes = typeof publicKey === 'string' ? hexToBytes(publicKey) : publicKey;
    const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBytes));
    return base58CheckEncode(version, publicKeyHash160);
}
function getPublicKeyFromPrivate(privateKey) {
    const privateKeyBytes = privateKeyToBytes(privateKey);
    return bytesToHex(getPublicKey(privateKeyBytes.slice(0, 32), true));
}
function ecSign(messageHash, hexPrivateKey) {
    return signSync(messageHash, privateKeyToBytes(hexPrivateKey).slice(0, 32), {
        der: false,
    });
}
function isValidPrivateKey(privateKey) {
    return utils.isValidPrivateKey(privateKeyToBytes(privateKey));
}
function compressPrivateKey(privateKey) {
    const privateKeyBytes = privateKeyToBytes(privateKey);
    return privateKeyBytes.length == PRIVATE_KEY_COMPRESSED_LENGTH
        ? privateKeyBytes
        : concatBytes(privateKeyBytes, new Uint8Array([1]));
}

const MAX_SAFE_INTEGER = 9007199254740991;
function ensureUInt53(n) {
    if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
        throw new RangeError('value out of range');
}
function encode(number, bytes, offset = 0) {
    ensureUInt53(number);
    if (!bytes)
        bytes = new Uint8Array(encodingLength(number));
    if (number < 0xfd) {
        writeUInt8(bytes, number, offset);
    }
    else if (number <= 65535) {
        writeUInt8(bytes, 0xfd, offset);
        writeUInt16LE(bytes, number, offset + 1);
    }
    else if (number <= 4294967295) {
        writeUInt8(bytes, 0xfe, offset);
        writeUInt32LE(bytes, number, offset + 1);
    }
    else {
        writeUInt8(bytes, 0xff, offset);
        writeUInt32LE(bytes, number >>> 0, offset + 1);
        writeUInt32LE(bytes, (number / 4294967296) | 0, offset + 5);
    }
    return bytes;
}
function decode(bytes, offset = 0) {
    const first = readUInt8(bytes, offset);
    if (first < 0xfd) {
        return first;
    }
    else if (first === 0xfd) {
        return readUInt16LE(bytes, offset + 1);
    }
    else if (first === 0xfe) {
        return readUInt32LE(bytes, offset + 1);
    }
    else {
        const lo = readUInt32LE(bytes, offset + 1);
        const hi = readUInt32LE(bytes, offset + 5);
        const number = hi * 4294967296 + lo;
        ensureUInt53(number);
        return number;
    }
}
function encodingLength(number) {
    ensureUInt53(number);
    return number < 0xfd ? 1 : number <= 65535 ? 3 : number <= 4294967295 ? 5 : 9;
}

const chainPrefix = '\x17Stacks Signed Message:\n';
function hashMessage(message, prefix = chainPrefix) {
    return sha256(encodeMessage(message, prefix));
}
function encodeMessage(message, prefix = chainPrefix) {
    const messageBytes = typeof message == 'string' ? utf8ToBytes(message) : message;
    const encodedLength = encode(messageBytes.length);
    return concatBytes(utf8ToBytes(prefix), encodedLength, messageBytes);
}
function decodeMessage(encodedMessage, prefix = chainPrefix) {
    const prefixByteLength = utf8ToBytes(prefix).byteLength;
    const messageWithoutChainPrefix = encodedMessage.subarray(prefixByteLength);
    const decoded = decode(messageWithoutChainPrefix);
    const varIntLength = encodingLength(decoded);
    return messageWithoutChainPrefix.slice(varIntLength);
}

function getAesCbcOutputLength(inputByteLength) {
    const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;
    return cipherTextLength;
}
function getBase64OutputLength(inputByteLength) {
    const encodedLength = Math.ceil(inputByteLength / 3) * 4;
    return encodedLength;
}
function hashCode(string) {
    let hash = 0;
    if (string.length === 0)
        return hash;
    for (let i = 0; i < string.length; i++) {
        const character = string.charCodeAt(i);
        hash = (hash << 5) - hash + character;
        hash &= hash;
    }
    return hash & 0x7fffffff;
}

utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac.create(sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
var InvalidPublicKeyReason;
(function (InvalidPublicKeyReason) {
    InvalidPublicKeyReason["InvalidFormat"] = "InvalidFormat";
    InvalidPublicKeyReason["IsNotPoint"] = "IsNotPoint";
})(InvalidPublicKeyReason || (InvalidPublicKeyReason = {}));
async function aes256CbcEncrypt(iv, key, plaintext) {
    const cipher = await createCipher();
    return await cipher.encrypt('aes-256-cbc', key, iv, plaintext);
}
async function aes256CbcDecrypt(iv, key, ciphertext) {
    const cipher = await createCipher();
    return await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);
}
function hmacSha256(key, content) {
    return hmac(sha256, key, content);
}
function equalsConstTime(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    let res = 0;
    for (let i = 0; i < a.length; i++) {
        res |= a[i] ^ b[i];
    }
    return res === 0;
}
function sharedSecretToKeys(sharedSecret) {
    const hashedSecret = hashSha512Sync(sharedSecret);
    return {
        encryptionKey: hashedSecret.slice(0, 32),
        hmacKey: hashedSecret.slice(32),
    };
}
function allHexChars(maybe) {
    return maybe.match(/^[0-9a-f]+$/i) !== null;
}
function isValidPublicKey(pub) {
    const invalidFormat = {
        result: false,
        reason_data: 'Invalid public key format',
        reason: InvalidPublicKeyReason.InvalidFormat,
    };
    const invalidPoint = {
        result: false,
        reason_data: 'Public key is not a point',
        reason: InvalidPublicKeyReason.IsNotPoint,
    };
    if (pub.length !== 66 && pub.length !== 130)
        return invalidFormat;
    const firstByte = pub.slice(0, 2);
    if (pub.length === 130 && firstByte !== '04')
        return invalidFormat;
    if (pub.length === 66 && firstByte !== '02' && firstByte !== '03')
        return invalidFormat;
    if (!allHexChars(pub))
        return invalidFormat;
    try {
        const point = Point.fromHex(pub);
        point.assertValidity();
        return {
            result: true,
            reason_data: null,
            reason: null,
        };
    }
    catch (e) {
        return invalidPoint;
    }
}
function getHexFromBN(bnInput) {
    const hexOut = bnInput.toString(16);
    if (hexOut.length === 64) {
        return hexOut;
    }
    else if (hexOut.length < 64) {
        const padding = '0'.repeat(64 - hexOut.length);
        return `${padding}${hexOut}`;
    }
    else {
        throw new Error('Generated a > 32-byte BN for encryption. Failing.');
    }
}
function getBytesFromBN(bnInput) {
    const result = bigIntToBytes(bnInput, 32);
    if (result.byteLength !== 32) {
        throw new Error('Failed to generate a 32-byte Uint8Array');
    }
    return result;
}
function getCipherObjectWrapper(opts) {
    const shell = {
        iv: '',
        ephemeralPK: '',
        mac: '',
        cipherText: '',
        wasString: !!opts.wasString,
    };
    if (opts.cipherTextEncoding === 'base64') {
        shell.cipherTextEncoding = 'base64';
    }
    const ivLength = 32;
    const ephemeralPKLength = 66;
    const macLength = 64;
    return {
        payloadValuesLength: ivLength + ephemeralPKLength + macLength,
        payloadShell: JSON.stringify(shell),
    };
}
function getSignedCipherObjectWrapper(payloadShell) {
    const shell = {
        signature: '',
        publicKey: '',
        cipherText: payloadShell,
    };
    const signatureLength = 144;
    const publicKeyLength = 66;
    return {
        signedPayloadValuesLength: signatureLength + publicKeyLength,
        signedPayloadShell: JSON.stringify(shell),
    };
}
function eciesGetJsonStringLength(opts) {
    const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);
    const cipherTextLength = getAesCbcOutputLength(opts.contentLength);
    let encodedCipherTextLength;
    if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {
        encodedCipherTextLength = cipherTextLength * 2;
    }
    else if (opts.cipherTextEncoding === 'base64') {
        encodedCipherTextLength = getBase64OutputLength(cipherTextLength);
    }
    else {
        throw new Error(`Unexpected cipherTextEncoding "${opts.cipherTextEncoding}"`);
    }
    if (!opts.sign) {
        return payloadShell.length + payloadValuesLength + encodedCipherTextLength;
    }
    else {
        const { signedPayloadShell, signedPayloadValuesLength } = getSignedCipherObjectWrapper(payloadShell);
        return (signedPayloadShell.length +
            signedPayloadValuesLength +
            payloadValuesLength +
            encodedCipherTextLength);
    }
}
async function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {
    const validity = isValidPublicKey(publicKey);
    if (!validity.result) {
        throw validity;
    }
    const ephemeralPrivateKey = utils.randomPrivateKey();
    const ephemeralPublicKey = getPublicKey(ephemeralPrivateKey, true);
    let sharedSecret = getSharedSecret(ephemeralPrivateKey, publicKey, true);
    sharedSecret = sharedSecret.slice(1);
    const sharedKeys = sharedSecretToKeys(sharedSecret);
    const initializationVector = utils.randomBytes(16);
    const cipherText = await aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);
    const macData = concatBytes(initializationVector, ephemeralPublicKey, cipherText);
    const mac = hmacSha256(sharedKeys.hmacKey, macData);
    let cipherTextString;
    if (!cipherTextEncoding || cipherTextEncoding === 'hex') {
        cipherTextString = bytesToHex(cipherText);
    }
    else if (cipherTextEncoding === 'base64') {
        cipherTextString = fromByteArray(cipherText);
    }
    else {
        throw new Error(`Unexpected cipherTextEncoding "${cipherTextEncoding}"`);
    }
    const result = {
        iv: bytesToHex(initializationVector),
        ephemeralPK: bytesToHex(ephemeralPublicKey),
        cipherText: cipherTextString,
        mac: bytesToHex(mac),
        wasString,
    };
    if (cipherTextEncoding && cipherTextEncoding !== 'hex') {
        result.cipherTextEncoding = cipherTextEncoding;
    }
    return result;
}
async function decryptECIES(privateKey, cipherObject) {
    if (!cipherObject.ephemeralPK) {
        throw new FailedDecryptionError('Unable to get public key from cipher object. ' +
            'You might be trying to decrypt an unencrypted object.');
    }
    const ephemeralPK = cipherObject.ephemeralPK;
    let sharedSecret = getSharedSecret(privateKey, ephemeralPK, true);
    sharedSecret = sharedSecret.slice(1);
    const sharedKeys = sharedSecretToKeys(sharedSecret);
    const ivBytes = hexToBytes(cipherObject.iv);
    let cipherTextBytes;
    if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {
        cipherTextBytes = hexToBytes(cipherObject.cipherText);
    }
    else if (cipherObject.cipherTextEncoding === 'base64') {
        cipherTextBytes = toByteArray(cipherObject.cipherText);
    }
    else {
        throw new Error(`Unexpected cipherTextEncoding "${cipherObject.cipherText}"`);
    }
    const macData = concatBytes(ivBytes, hexToBytes(ephemeralPK), cipherTextBytes);
    const actualMac = hmacSha256(sharedKeys.hmacKey, macData);
    const expectedMac = hexToBytes(cipherObject.mac);
    if (!equalsConstTime(expectedMac, actualMac)) {
        throw new FailedDecryptionError('Decryption failed: failure in MAC check');
    }
    const plainText = await aes256CbcDecrypt(ivBytes, sharedKeys.encryptionKey, cipherTextBytes);
    if (cipherObject.wasString) {
        return bytesToUtf8(plainText);
    }
    return plainText;
}
function signECDSA(privateKey, content) {
    const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;
    const publicKey = getPublicKeyFromPrivate(privateKey);
    const contentHash = hashSha256Sync(contentBytes);
    const signature = signSync(contentHash, privateKey);
    return {
        signature: bytesToHex(signature),
        publicKey,
    };
}
function verifyECDSA(content, publicKey, signature) {
    const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;
    const contentHash = hashSha256Sync(contentBytes);
    return verify(signature, contentHash, publicKey, { strict: false });
}
function verifyMessageSignature({ signature, message, publicKey, }) {
    const { r, s } = parseRecoverableSignatureVrs(signature);
    const sig = new Signature(hexToBigInt(r), hexToBigInt(s));
    const hashedMsg = typeof message === 'string' ? hashMessage(message) : message;
    const verificationResult = verify(sig, hashedMsg, publicKey, { strict: false });
    if (verificationResult || typeof message !== 'string')
        return verificationResult;
    const LEGACY_PREFIX = '\x18Stacks Message Signing:\n';
    const legacyHash = sha256(encodeMessage(message, LEGACY_PREFIX));
    return verify(sig, legacyHash, publicKey, { strict: false });
}
function verifyMessageSignatureRsv({ signature, message, publicKey, }) {
    return verifyMessageSignature({
        signature: signatureRsvToVrs(signature),
        message,
        publicKey,
    });
}

const randomBytes = (bytesLength = 32) => utils.randomBytes(bytesLength);

async function encryptContent(content, options) {
    const opts = Object.assign({}, options);
    let privateKey;
    if (!opts.publicKey) {
        if (!opts.privateKey) {
            throw new Error('Either public key or private key must be supplied for encryption.');
        }
        opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);
    }
    const wasString = typeof opts.wasString === 'boolean' ? opts.wasString : typeof content === 'string';
    const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;
    const cipherObject = await encryptECIES(opts.publicKey, contentBytes, wasString, opts.cipherTextEncoding);
    let cipherPayload = JSON.stringify(cipherObject);
    if (opts.sign) {
        if (typeof opts.sign === 'string') {
            privateKey = opts.sign;
        }
        else if (!privateKey) {
            privateKey = opts.privateKey;
        }
        const signatureObject = signECDSA(privateKey, cipherPayload);
        const signedCipherObject = {
            signature: signatureObject.signature,
            publicKey: signatureObject.publicKey,
            cipherText: cipherPayload,
        };
        cipherPayload = JSON.stringify(signedCipherObject);
    }
    return cipherPayload;
}
function decryptContent(content, options) {
    const opts = Object.assign({}, options);
    if (!opts.privateKey) {
        throw new Error('Private key is required for decryption.');
    }
    try {
        const cipherObject = JSON.parse(content);
        return decryptECIES(opts.privateKey, cipherObject);
    }
    catch (err) {
        if (err instanceof SyntaxError) {
            throw new Error('Failed to parse encrypted content JSON. The content may not ' +
                'be encrypted. If using getFile, try passing { decrypt: false }.');
        }
        else {
            throw err;
        }
    }
}

class NodeCryptoPbkdf2 {
    constructor(nodePbkdf2) {
        this.nodePbkdf2 = nodePbkdf2;
    }
    async derive(password, salt, iterations, keyLength, digest) {
        if (digest !== 'sha512' && digest !== 'sha256') {
            throw new Error(`Unsupported digest "${digest}" for Pbkdf2`);
        }
        return new Promise((resolve, reject) => {
            this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {
                if (error) {
                    reject(error);
                }
                resolve(result);
            });
        });
    }
}
class WebCryptoPbkdf2 {
    constructor(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    async derive(password, salt, iterations, keyLength, digest) {
        let algo;
        if (digest === 'sha256') {
            algo = 'SHA-256';
        }
        else if (digest === 'sha512') {
            algo = 'SHA-512';
        }
        else {
            throw new Error(`Unsupported Pbkdf2 digest algorithm "${digest}"`);
        }
        const passwordBytes = utf8ToBytes(password);
        try {
            const key = await this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, [
                'deriveBits',
            ]);
            const result = await this.subtleCrypto.deriveBits({
                name: 'PBKDF2',
                salt,
                iterations,
                hash: { name: algo },
            }, key, keyLength * 8);
            return new Uint8Array(result);
        }
        catch (error) {
            const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);
            return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);
        }
    }
}
class WebCryptoPartialPbkdf2 {
    constructor(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    async derive(password, salt, iterations, keyLength, digest) {
        if (digest !== 'sha512' && digest !== 'sha256') {
            throw new Error(`Unsupported digest "${digest}" for Pbkdf2`);
        }
        const passwordBytes = utf8ToBytes(password);
        const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';
        const algoOpts = { name: 'HMAC', hash: algo };
        const hmacDigest = (key, data) => this.subtleCrypto
            .importKey('raw', key, algoOpts, true, ['sign'])
            .then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data))
            .then(result => new Uint8Array(result));
        const DK = new Uint8Array(keyLength);
        const saltLength = salt.length;
        const block1 = new Uint8Array(saltLength + 4);
        block1.set(salt);
        let destPos = 0;
        const hLen = digest === 'sha512' ? 64 : 32;
        const l = Math.ceil(keyLength / hLen);
        for (let i = 1; i <= l; i++) {
            writeUInt32BE(block1, i, saltLength);
            const T = await hmacDigest(passwordBytes, block1);
            let U = T;
            for (let j = 1; j < iterations; j++) {
                U = await hmacDigest(passwordBytes, U);
                for (let k = 0; k < hLen; k++) {
                    T[k] ^= U[k];
                }
            }
            DK.set(T.subarray(0, DK.byteLength - destPos), destPos);
            destPos += hLen;
        }
        return DK;
    }
}
async function createPbkdf2() {
    const cryptoLib = await getCryptoLib();
    if (cryptoLib.name === 'subtleCrypto') {
        return new WebCryptoPbkdf2(cryptoLib.lib);
    }
    return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);
}

async function encryptMnemonic(phrase, password, opts) {
    let mnemonicEntropy;
    try {
        const entropyBytes = mnemonicToEntropy(phrase, wordlist);
        mnemonicEntropy = bytesToHex(entropyBytes);
    }
    catch (error) {
        console.error('Invalid mnemonic phrase provided');
        console.error(error);
        throw new Error('Not a valid bip39 mnemonic');
    }
    const plaintextNormalized = hexToBytes(mnemonicEntropy);
    const pbkdf2 = await createPbkdf2();
    const salt = opts?.getRandomBytes ? opts.getRandomBytes(16) : randomBytes(16);
    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');
    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);
    const cipher = await createCipher();
    const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);
    const hmacPayload = concatBytes(salt, cipherText);
    const hmacDigest = hmacSha256(macKey, hmacPayload);
    const payload = concatBytes(salt, hmacDigest, cipherText);
    return payload;
}
class PasswordError extends Error {
}
async function decryptMnemonicBytes(dataBytes, password) {
    const salt = dataBytes.slice(0, 16);
    const hmacSig = dataBytes.slice(16, 48);
    const cipherText = dataBytes.slice(48);
    const hmacPayload = concatBytes(salt, cipherText);
    const pbkdf2 = await createPbkdf2();
    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');
    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);
    const decipher = await createCipher();
    const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);
    const hmacDigest = hmacSha256(macKey, hmacPayload);
    const sha2Hash = await createSha2Hash();
    const hmacSigHash = await sha2Hash.digest(hmacSig);
    const hmacDigestHash = await sha2Hash.digest(hmacDigest);
    if (!equals(hmacSigHash, hmacDigestHash)) {
        throw new PasswordError('Wrong password (HMAC mismatch)');
    }
    let mnemonic;
    try {
        mnemonic = entropyToMnemonic(decryptedResult, wordlist);
    }
    catch (error) {
        console.error('Error thrown by `entropyToMnemonic`');
        console.error(error);
        throw new PasswordError('Wrong password (invalid plaintext)');
    }
    if (!validateMnemonic(mnemonic, wordlist)) {
        throw new PasswordError('Wrong password (invalid plaintext)');
    }
    return mnemonic;
}
function decryptLegacy(dataBytes, password, triplesecDecrypt) {
    return new Promise((resolve, reject) => {
        if (!triplesecDecrypt) {
            reject(new Error('The `triplesec.decrypt` function must be provided'));
        }
        triplesecDecrypt({
            key: utf8ToBytes(password),
            data: dataBytes,
        }, (err, plaintextBytes) => {
            if (!err) {
                resolve(plaintextBytes);
            }
            else {
                reject(err);
            }
        });
    });
}
async function decryptMnemonic(data, password, triplesecDecrypt) {
    const dataBytes = typeof data === 'string' ? hexToBytes(data) : data;
    try {
        return await decryptMnemonicBytes(dataBytes, password);
    }
    catch (error) {
        if (error instanceof PasswordError)
            throw error;
        const data = await decryptLegacy(dataBytes, password, triplesecDecrypt);
        return bytesToUtf8(data);
    }
}

export { InvalidPublicKeyReason, NodeCryptoSha2Hash, WebCryptoSha2Hash, aes256CbcEncrypt, base58CheckDecode, base58CheckEncode, base58Encode, compressPrivateKey, createSha2Hash, decodeMessage, decryptContent, decryptECIES, decryptMnemonic, ecSign, eciesGetJsonStringLength, encodeMessage, encryptContent, encryptECIES, encryptMnemonic, getAesCbcOutputLength, getBase64OutputLength, getBytesFromBN, getCipherObjectWrapper, getHexFromBN, getPublicKeyFromPrivate, getSignedCipherObjectWrapper, hashCode, hashMessage, hashSha256Sync, hashSha512Sync, hmacSha256, isValidPrivateKey, makeECPrivateKey, publicKeyToBtcAddress, randomBytes, signECDSA, verifyECDSA, verifyMessageSignature, verifyMessageSignatureRsv };
